<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTA –õ–Å–•–ê (V12.10 - –£–†–û–ù –ó–ê –ì–†–ê–ù–ò–¶–ï–ô –ù–ê –ú–ê–®–ò–ù–ï)</title>
    <style>
        /* --- –°–¢–ò–õ–ò --- */
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; user-select: none; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }

        /* CROSSHAIR */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><circle cx="10" cy="10" r="2" fill="white" stroke="black"/><path d="M10,0 L10,6 M10,14 L10,20 M0,10 L6,10 M14,10 L20,10" stroke="black" stroke-width="1"/></svg>') no-repeat center;
            transform: translate(-50%, -50%); z-index: 10; pointer-events: none;
        }

        /* HUD */
        #hud {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            text-align: right; color: white; text-shadow: 2px 2px 2px #000; font-weight: bold;
        }
        
        #carHint {
            position: absolute; bottom: 20%; width: 100%; text-align: center;
            color: #ffff00; font-size: 2em; text-shadow: 2px 2px 4px black; display: none;
            animation: bounce 1s infinite;
        }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }

        /* BOUNDARY WARNING */
        #boundaryWarning {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; justify-content: center; align-items: center;
            background: rgba(255, 0, 0, 0.4); 
            color: white; font-size: 4em; font-weight: bold;
            text-shadow: 0 0 10px black;
            z-index: 50; 
            pointer-events: none;
            text-align: center;
            padding: 20px;
        }

        /* --- –ú–ò–ù–ò-–ö–ê–†–¢–ê --- */
        #miniMap {
            position: absolute; bottom: 20px; left: 20px; z-index: 10;
            width: 200px; height: 200px; 
            background: #888888; 
            border: 3px solid white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        #mapContent {
            position: absolute;
            width: 200px;
            height: 200px;
            transform-origin: 50% 50%; 
        }

        /* –ú–∞—Ä–∫–µ—Ä—ã –∏ —ç–ª–µ–º–µ–Ω—Ç—ã 2D –∫–∞—Ä—Ç—ã */
        .mapMarker {
            position: absolute;
            width: 8px; height: 8px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        /* --- –ú–∞—Ä–∫–µ—Ä –∏–≥—Ä–æ–∫–∞ (—É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π) --- */
        #playerMarker { 
            background-color: lime; 
            border: 2px solid white; 
            z-index: 5; 
            width: 12px; 
            height: 12px;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.8); 
        }
        /* ----------------------------------- */
        .policeMarker { background-color: red; border: 1px solid black; z-index: 4; }
        .mapBuilding {
            position: absolute;
            background-color: #228b22; 
            border: 1px solid #000;
            box-sizing: border-box;
            opacity: 0.8;
        }

        /* --- –ú–ï–ù–Æ --- */
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0f0f0f 0%, #3a0000 100%); 
            background-size: 200% 200%; 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: white;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
            animation: backgroundShift 15s infinite alternate; 
        }
        @keyframes backgroundShift {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }

        #menu h1 { 
            font-size: 7em; color: #ff0000; margin: 0; 
            text-shadow: 6px 6px 0px #000, 8px 8px 15px rgba(255, 0, 0, 0.7); 
            font-family: 'Impact', sans-serif;
            letter-spacing: 10px;
            animation: titlePulse 2s infinite alternate; 
        }
        @keyframes titlePulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }
        
        #menu #subtitle {
            font-size: 2em; color: #ffaa00; text-shadow: 2px 2px 0px black;
            margin-top: 10px;
        }

        #menu button {
            background: #ffaa00;
            color: black;
            border: 5px solid #ff0000; 
            padding: 20px 40px;
            font-size: 1.8em;
            cursor: pointer;
            margin: 15px;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            transform: skew(-5deg); 
        }
        #menu button:hover {
            background: #ffcc00;
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.9);
            transform: skew(-5deg) scale(1.05); 
            border-color: #ffffff;
        }
        
        /* BUSTED SCREEN (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π) */
        #bustedScreen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: red;
            flex-direction: column; justify-content: center; align-items: center; z-index: 100;
        }
        #bustedScreen h1 {
            font-family: Impact; letter-spacing: 5px; color: red;
            font-size: 6em;
        }
        #bustedScreen h2 {
            font-size: 2.5em; color: #fff; margin-top: 10px;
        }

        /* HELP BOX */
        #infoBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 5px solid red;
            padding: 40px;
            color: white;
            font-size: 1.2em;
            text-align: left;
            z-index: 101;
            display: none;
            box-shadow: 0 0 30px red;
            max-width: 600px;
        }
        #infoBox button {
            margin-top: 20px;
            background: red;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 1em;
            display: block;
            width: 100%;
        }
        #infoBox h3 {
            text-align: center;
            color: #ffaa00;
            border-bottom: 2px solid red;
            padding-bottom: 10px;
        }
        #infoBox p, #infoBox ul {
             margin-bottom: 15px;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="carHint">–ù–ê–ñ–ú–ò–¢–ï [F], –ß–¢–û–ë–´ –°–ï–°–¢–¨ –í –ú–ê–®–ò–ù–£</div>
    <div id="boundaryWarning"></div>
    
    <div id="hud">
        <div id="timeDisplay">12:00</div>
        <div id="hpDisplay" style="color: red; margin-top: 5px;">‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: 100</div>
        <div id="weaponDisplay" style="color: orange; margin-top: 5px;">üëä –ö–£–õ–ê–ö–ò</div>
        <div id="wantedLevel" style="color: white; margin-top: 5px;">‚òÖ –†–û–ó–´–°–ö: 0</div>
        <div style="font-size: 0.8em; color: #ffff00; margin-top:10px;">V12.10 (–£–†–û–ù –ó–ê –ì–†–ê–ù–ò–¶–ï–ô)</div>
    </div>
    
    <div id="miniMap">
        <div id="mapContent">
             <div id="playerMarker" class="mapMarker" style="left: 50%; top: 50%;"></div>
        </div>
    </div>

    <div id="menu">
        <div>
            <span class="bomb-emoji" style="font-size: 3em; margin-right: 20px;">üö®</span>
            <h1>GTA –õ–Å–•–ê</h1>
            <span class="bomb-emoji" style="font-size: 3em; margin-left: 20px;">üöì</span>
        </div>
        <div id="subtitle" style="font-size: 1.5em; color: #ffaa00; text-shadow: 2px 2px 0px black;">–°–ê–ú–´–ô –ö–†–ò–ú–ò–ù–ê–õ–¨–ù–´–ô –°–ò–ú–£–õ–Ø–¢–û–†</div>
        <p style="margin-top: 50px; font-size: 1.8em; color: yellow; text-shadow: 2px 2px black;">–°–û–ó–î–ê–ù–û –¢–ò–ú–£–†–û–ú</p>
        <div class="menu-options">
            <button id="startBtn">–ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button>
            <button id="help-btn">–ü–û–ú–û–©–¨</button>
        </div>
    </div>

    <div id="infoBox">
        <h3>–ü–û–ú–û–©–¨: GTA –õ–Å–•–ê</h3>

        <h4>üìñ –°—é–∂–µ—Ç –∏ –°–º—ã—Å–ª</h4>
        <p>–¢—ã, –õ—ë—Ö–∞, ‚Äî –∫—Ä—É—Ç–æ–π —á—É–≤–∞–∫ –≤ –±–æ–ª—å—à–æ–º –≥–æ—Ä–æ–¥–µ, –∫–æ—Ç–æ—Ä—ã–π –≤—Å–µ–≥–¥–∞ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ –∫–∞–∫–∏–µ-—Ç–æ –ø–µ—Ä–µ–¥—Ä—è–≥–∏. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî **–≤—ã–∂–∏—Ç—å, –ø–æ–¥–Ω—è—Ç—å —É—Ä–æ–≤–µ–Ω—å —Ä–æ–∑—ã—Å–∫–∞ –∏ –∏–∑–±–µ–≥–∞—Ç—å –º–µ–Ω—Ç–æ–≤!**</p>
        <p>**–í–ù–ò–ú–ê–ù–ò–ï:** –ù–µ –ª–µ–∑—å –∑–∞ –∫—Ä–∞—Å–Ω—É—é —á–µ—Ä—Ç—É, —ç—Ç–æ –±–æ–ª—å–Ω–æ!</p>

        <h4>üéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h4>
        <ul>
            <li>**WASD:** –î–≤–∏–∂–µ–Ω–∏–µ (—Ö–æ–¥—å–±–∞/–µ–∑–¥–∞)</li>
            <li>**–ú—ã—à—å:** –û–±–∑–æ—Ä/–ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã</li>
            <li>**–õ–ö–ú (–õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏):** –£–¥–∞—Ä / –í—ã—Å—Ç—Ä–µ–ª</li>
            <li>**F:** –°–µ—Å—Ç—å –≤ –º–∞—à–∏–Ω—É / –í—ã–π—Ç–∏ –∏–∑ –º–∞—à–∏–Ω—ã</li>
            <li>**–ü–†–û–ë–ï–õ (Space):** **–ü—Ä—ã–∂–æ–∫**</li>
            <li>**1:** –í—ã–±—Ä–∞—Ç—å **–ö—É–ª–∞–∫–∏** üëä</li>
            <li>**2:** –í—ã–±—Ä–∞—Ç—å **–ü–∏—Å—Ç–æ–ª–µ—Ç** üî´</li>
        </ul>

        <h4>üö® –†–æ–∑—ã—Å–∫ –∏ –ü–æ–ª–∏—Ü–∏—è</h4>
        <p>–ö–∞–∂–¥–æ–µ —É–±–∏–π—Å—Ç–≤–æ (–ø–µ—à–µ—Ö–æ–¥–∞ –∏–ª–∏ –ø–æ–ª–∏—Ü–µ–π—Å–∫–æ–≥–æ) –ø–æ–≤—ã—à–∞–µ—Ç —É—Ä–æ–≤–µ–Ω—å —Ä–æ–∑—ã—Å–∫–∞ (‚òÖ). –ü–æ–ª–∏—Ü–∏—è —Ç–µ–ø–µ—Ä—å —Å—Ç—Ä–µ–ª—è–µ—Ç –∏–∑–¥–∞–ª–µ–∫–∞, –∞ –≤ –º–∞—à–∏–Ω–µ –±—É–¥–µ—Ç –≤–∞—Å **–ø—Ä–µ—Å–ª–µ–¥–æ–≤–∞—Ç—å –∏ –æ–±—Å—Ç—Ä–µ–ª–∏–≤–∞—Ç—å**!</p>
        <p>–†–æ–∑—ã—Å–∫ —Å–ø–∞–¥–∞–µ—Ç —á–µ—Ä–µ–∑ **15 —Å–µ–∫—É–Ω–¥**, –µ—Å–ª–∏ –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏ –Ω–µ—Ç –ø–æ–ª–∏—Ü–∏–∏.</p>
        <p><strong>–ù–û–í–ò–ù–ö–ê:</strong> –ü–æ–ø—ã—Ç–∫–∞ –≤—ã–µ—Ö–∞—Ç—å –∏–ª–∏ –≤—ã–π—Ç–∏ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –≥–æ—Ä–æ–¥–∞ –Ω–∞–Ω–æ—Å–∏—Ç —É—Ä–æ–Ω **12 HP –≤ —Å–µ–∫—É–Ω–¥—É**!</p>

        <button onclick="document.getElementById('infoBox').style.display='none'">–ó–ê–ö–†–´–¢–¨</button>
    </div>

    <div id="bustedScreen">
        <h1>–ü–û–ô–ú–ê–ù</h1>
        <h2>–®–û –¢–£–¢ –î–£–ú–ê–õ –í –°–ö–ê–ó–ö–£ –ü–û–ü–ê–õ</h2>
        <button onclick="location.reload()" style="background: red; border-color: #ff3333;">–ü–û–í–¢–û–†–ò–¢–¨</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // === –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø GTA LITE 3D (V12.10) ===
        const CAMERA_HEIGHT = 1.5;
        const NPC_COUNT = 200;       
        const POLICE_COUNT = 20;     
        const TRAFFIC_CAR_COUNT = 15; 
        const RESPAWN_INTERVAL = 90 * 1000; 
        const MAP_SIZE = 400; 
        const BORDER_COLLISION_SIZE = 5; 
        const VISIBLE_WALL_HEIGHT = 1; 
        const PLAYER_COLLISION_RADIUS = 1.5; 
        const MINIMAP_SIZE_PX = 200; 
        const MINIMAP_SCALE = 0.8; 
        const MAP_VIEW_RADIUS = MINIMAP_SIZE_PX / MINIMAP_SCALE / 2; 
        const BOUNDARY_RANGE = 50; 
        const BOUNDARY_DAMAGE_AREA = MAP_SIZE - BOUNDARY_RANGE; // –ì—Ä–∞–Ω–∏—Ü–∞ –Ω–∞–Ω–µ—Å–µ–Ω–∏—è —É—Ä–æ–Ω–∞
        const WANTED_DECAY_TIME = 15; // –°–µ–∫—É–Ω–¥ –Ω–∞ –ø–æ–Ω–∏–∂–µ–Ω–∏–µ 1 —É—Ä–æ–≤–Ω—è —Ä–æ–∑—ã—Å–∫–∞
        const BOUNDARY_DAMAGE_DPS = 12; // –£—Ä–æ–Ω –∑–∞ —Å–µ–∫—É–Ω–¥—É –∑–∞ –≥—Ä–∞–Ω–∏—Ü–µ–π (10-15 HP –ø–æ –∑–∞–ø—Ä–æ—Å—É)

        // === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
        let scene, camera, renderer;
        let player, weaponGroup;
        let raycaster;
        
        const collisionObjects = [];
        const npcs = [];
        const cars = [];
        const particles = [];
        const mapBuildings = []; 
        
        let isGameActive = false;
        let currentCar = null;
        let moveFwd=false, moveBwd=false, moveLft=false, moveRgt=false;
        let prevTime = performance.now();
        
        let wantedLevel = 0;
        let playerHP = 100; 
        let currentWeapon = 'FIST';
        let gameTime = 10;
        let carSpeed = 0;
        let wantedDecayTimer = 0; 
        
        const carRaycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(), 0, 10);
        
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let policeCar = null;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 300);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            player = new THREE.Group();
            player.add(camera);
            player.position.set(0, CAMERA_HEIGHT, 0); 
            player.userData = { canJump: true, velocityY: 0 }; 
            scene.add(player);

            createWeapons();
            
            const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambLight);
            const sunLight = new THREE.DirectionalLight(0xffeebb, 0.9);
            sunLight.position.set(50, 150, 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.near = 1;
            sunLight.shadow.camera.far = 300;
            sunLight.shadow.camera.left = -300;
            sunLight.shadow.camera.right = 300;
            sunLight.shadow.camera.top = 300;
            sunLight.shadow.camera.bottom = -300;
            scene.add(sunLight);

            createCity();
            createStreetFurniture();
            
            createMapBounds(); 
            
            createEasterEggPullUp(150, 150, Math.PI); 
            createEasterEggPullUp(-150, -150, 0); 
            
            spawnParkingLotCars(); 
            
            spawnTraffic();
            
            spawnNPCs(POLICE_COUNT, true);
            spawnNPCs(NPC_COUNT - POLICE_COUNT, false);
            
            setInterval(respawnNPCs, RESPAWN_INTERVAL); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            
            const canvasElement = renderer.domElement;
            if (document.body.contains(canvasElement)) {
                 document.body.removeChild(canvasElement);
            }
            document.body.appendChild(canvasElement);

            raycaster = new THREE.Raycaster();
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }
        
        function updateWantedLevelDisplay() {
            const levelText = '‚òÖ'.repeat(wantedLevel);
            document.getElementById('wantedLevel').innerText = `‚òÖ –†–û–ó–´–°–ö: ${wantedLevel} ${levelText}`;
        }
        
        // --- –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ü–†–û–í–ï–†–ö–ê –ì–†–ê–ù–ò–¶ –ò –£–†–û–ù ---
        function checkBoundaryDamage(position, dt) {
            const boundaryWarning = document.getElementById('boundaryWarning');
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –ø–æ–∑–∏—Ü–∏—è –∑–∞ –≥—Ä–∞–Ω–∏—Ü–µ–π —É—Ä–æ–Ω–∞
            const isOutOfBounds = Math.abs(position.x) > BOUNDARY_DAMAGE_AREA || Math.abs(position.z) > BOUNDARY_DAMAGE_AREA;

            if (isOutOfBounds) {
                boundaryWarning.style.display = 'flex';
                boundaryWarning.innerText = "üõë –õ–Å–•–ê –î–£–†–ê–ß–û–ö –ù–ï –õ–ï–ó–¨ –¢–£–î–ê (–°–í–û–ë–û–î–ê –ù–ï –ù–ê–®–ï –ú–ï–°–¢–û)";

                // –£—Ä–æ–Ω 12 HP –≤ —Å–µ–∫—É–Ω–¥—É
                const damage = BOUNDARY_DAMAGE_DPS * dt; 
                playerHP -= damage;
                    
                if (playerHP <= 0) {
                    endGame();
                }
                
                document.getElementById('hpDisplay').innerText = `‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: ${Math.max(0, Math.floor(playerHP))}`;
                return true; // –ë—ã–ª –∑–∞ –≥—Ä–∞–Ω–∏—Ü–µ–π
            } else {
                boundaryWarning.style.display = 'none';
                return false; // –ë—ã–ª –≤ –≥—Ä–∞–Ω–∏—Ü–∞—Ö
            }
        }
        // ---------------------------------------------
        
        function movePlayer(dt) {
            const speed = 8; const dir = new THREE.Vector3();
            if (moveFwd) dir.z -= 1; if (moveBwd) dir.z += 1; if (moveLft) dir.x -= 1; if (moveRgt) dir.x += 1;
            dir.normalize().multiplyScalar(speed * dt);
            
            const moveVector = dir.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
            
            player.userData.velocityY -= 9.8 * dt * 2; 
            player.position.y += player.userData.velocityY * dt;
            
            if (player.position.y < CAMERA_HEIGHT) {
                player.position.y = CAMERA_HEIGHT;
                player.userData.canJump = true;
                player.userData.velocityY = 0;
            }
            
            const newPos = player.position.clone();
            newPos.x += moveVector.x;
            newPos.z += moveVector.z;
            newPos.y = CAMERA_HEIGHT; 

            let collided = false;

            for(let obj of collisionObjects) {
                const oPos = new THREE.Vector3();
                obj.updateWorldMatrix(true, false);
                oPos.setFromMatrixPosition(obj.matrixWorld); 
                oPos.y = 0;

                let isBuilding = obj.geometry.type === 'BoxGeometry' && obj.geometry.parameters.width > 10;

                if (isBuilding) { 
                    const w = obj.geometry.parameters.width / 2;
                    const d = obj.geometry.parameters.depth / 2;
                    const cushion = PLAYER_COLLISION_RADIUS;

                    if (
                        newPos.x > oPos.x - w - cushion && newPos.x < oPos.x + w + cushion &&
                        newPos.z > oPos.z - d - cushion && newPos.z < oPos.z + d + cushion
                    ) {
                        const overlapX = Math.min(newPos.x - (oPos.x - w), (oPos.x + w) - newPos.x);
                        const overlapZ = Math.min(newPos.z - (oPos.z - d), (oPos.z + d) - newPos.z);
                        
                        let push = new THREE.Vector3();
                        if (overlapX < overlapZ) {
                            const dirX = newPos.x > oPos.x ? 1 : -1;
                            push.x = dirX * (cushion - overlapX);
                        } else {
                            const dirZ = newPos.z > oPos.z ? 1 : -1;
                            push.z = dirZ * (cushion - overlapZ);
                        }

                        player.position.x += push.x;
                        player.position.z += push.z;
                        dir.set(0, 0, 0); 
                        collided = true;
                        break;
                    }
                } else if (newPos.distanceTo(oPos) < PLAYER_COLLISION_RADIUS) { 
                    const push = newPos.clone().sub(oPos).normalize().multiplyScalar(PLAYER_COLLISION_RADIUS - newPos.distanceTo(oPos)); 
                    player.position.x += push.x;
                    player.position.z += push.z;
                    dir.set(0, 0, 0); 
                    collided = true;
                    break;
                }
            }

            if (!collided) {
                player.translateX(dir.x); 
                player.translateZ(dir.z); 
            }
            
            // --- –õ–û–ì–ò–ö–ê –£–†–û–ù–ê –ó–ê –ì–†–ê–ù–ò–¶–ï–ô (–ü–ï–®–ö–û–ú) ---
            checkBoundaryDamage(player.position, dt);
            // ---------------------------------------

            let nearCar = false; cars.forEach(c => { if(player.position.distanceTo(c.position) < 5) nearCar = true; });
            document.getElementById('carHint').style.display = nearCar ? 'block' : 'none';
            if ((moveFwd||moveBwd||moveLft||moveRgt) && player.userData.canJump) weaponGroup.position.y = -0.4 + Math.sin(performance.now()*0.015)*0.02;
        }

        // === –ì–õ–û–ë–ê–õ–¨–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –í–´–°–¢–†–ï–õ–ê NPC ===
        function npcShoot(npc) {
            if (npc.userData.lastShot && performance.now() - npc.userData.lastShot < 1000) return; 
            if (currentCar) return; 

            playSound('shoot'); 
            npc.userData.lastShot = performance.now();
            
            const targetPos = player.position; 
            const direction = new THREE.Vector3().subVectors(targetPos, npc.position).normalize();
            
            raycaster.set(new THREE.Vector3(npc.position.x, 1.5, npc.position.z), direction);
            
            const intersectables = collisionObjects.concat(npcs).filter(o => o !== npc);
            const hits = raycaster.intersectObjects(intersectables.concat([player]), true); 
            
            if (hits.length > 0) {
                const hit = hits[0];
                
                let hitPlayer = false;
                let obj = hit.object;
                while (obj.parent) {
                    if (obj === player) {
                        hitPlayer = true;
                        break;
                    }
                    obj = obj.parent;
                }

                if (hitPlayer && hit.distance < 150) { 
                    const damage = Math.floor(Math.random() * 10) + 15; 
                    playerHP -= damage;
                    document.getElementById('hpDisplay').innerText = `‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: ${Math.max(0, Math.floor(playerHP))}`;
                    
                    if (playerHP <= 0) {
                        endGame(); 
                    }
                }
            }
        }
        
        // === –ê–¢–ê–ö–ê –ü–û–õ–ò–¶–ï–ô–°–ö–û–ô –ú–ê–®–ò–ù–´ ===
        function policeCarAttack(pCar, tCar) {
            const distance = pCar.position.distanceTo(tCar.position);
            const attackRange = 75; 
            const attackCooldown = 1500; 

            if (distance < attackRange && pCar.userData.lastShotTime + attackCooldown < performance.now()) {
                pCar.userData.lastShotTime = performance.now();
                playSound('shoot'); 

                if (Math.random() < 0.7) { 
                    const damage = Math.floor(Math.random() * 8) + 10; 
                    playerHP -= damage;
                    
                    document.getElementById('hpDisplay').innerText = `‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: ${Math.max(0, Math.floor(playerHP))}`;
                    
                    if (playerHP <= 0) {
                        endGame();
                    }
                }
            }
        }


        // === –ú–ò–ù–ò-–ö–ê–†–¢–ê ===
        function updateMiniMap() {
            const mapDiv = document.getElementById('mapContent');
            const mapW = MINIMAP_SIZE_PX;
            const mapH = MINIMAP_SIZE_PX;
            
            const playerX = currentCar ? currentCar.position.x : player.position.x;
            const playerZ = currentCar ? currentCar.position.z : player.position.z;

            const offsetMapX = mapW / 2 - playerX * MINIMAP_SCALE;
            const offsetMapZ = mapH / 2 - (-playerZ * MINIMAP_SCALE); 

            mapDiv.style.transform = `translate(${offsetMapX}px, ${offsetMapZ}px)`;

            Array.from(mapDiv.children).forEach(el => {
                if (el.id !== 'playerMarker') el.remove();
            });

            // –†–ò–°–û–í–ê–ù–ò–ï –ó–î–ê–ù–ò–ô 
            mapBuildings.forEach(building => {
                const dist = Math.sqrt(Math.pow(building.x - playerX, 2) + Math.pow(building.z - playerZ, 2));
                if (dist > MAP_VIEW_RADIUS * 1.5) return;

                const mapRelX = building.x * MINIMAP_SCALE;
                const mapRelZ = -building.z * MINIMAP_SCALE;

                const bDiv = document.createElement('div');
                bDiv.className = 'mapBuilding';
                bDiv.style.width = `${building.w * MINIMAP_SCALE}px`;
                bDiv.style.height = `${building.d * MINIMAP_SCALE}px`;
                
                bDiv.style.left = `${mapRelX - (building.w * MINIMAP_SCALE / 2)}px`;
                bDiv.style.top = `${mapRelZ - (building.d * MINIMAP_SCALE / 2)}px`;

                mapDiv.appendChild(bDiv);
            });
            
            // –ú–ê–†–ö–ï–† –ò–ì–†–û–ö–ê
            const playerMarker = document.getElementById('playerMarker');
            playerMarker.style.left = `${playerX * MINIMAP_SCALE}px`;
            playerMarker.style.top = `${-playerZ * MINIMAP_SCALE}px`;
            
            // –ú–ê–†–ö–ï–†–´ –ü–û–õ–ò–¶–ò–ò
            npcs.filter(n => n.userData.isPolice && wantedLevel > 0).forEach(npc => {
                const npcX = npc.position.x;
                const npcZ = npc.position.z;
                
                if (Math.abs(npcX - playerX) < MAP_VIEW_RADIUS && Math.abs(npcZ - playerZ) < MAP_VIEW_RADIUS) {
                    
                    const mapRelX = npcX * MINIMAP_SCALE;
                    const mapRelZ = -npcZ * MINIMAP_SCALE;

                    const marker = document.createElement('div');
                    marker.className = 'mapMarker policeMarker';
                    
                    marker.style.left = `${mapRelX}px`;
                    marker.style.top = `${mapRelZ}px`;
                    mapDiv.appendChild(marker);
                }
            });
        }


        // === –û–°–ù–û–í–ù–û–ô –¶–ò–ö–õ –ê–ù–ò–ú–ê–¶–ò–ò ===
        function animate() {
            requestAnimationFrame(animate);
            if (!isGameActive) return;
            const dt = (performance.now() - prevTime) / 1000; prevTime = performance.now();
            gameTime += dt * 0.05; if (gameTime>=24) gameTime=0; document.getElementById('timeDisplay').innerText = Math.floor(gameTime)+":00";

            if (currentCar) {
                // –õ–æ–≥–∏–∫–∞ –≤–æ–∂–¥–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞
                if (moveFwd) carSpeed += 40 * dt; 
                if (moveBwd) carSpeed -= 25 * dt; 
                carSpeed *= 0.99; 
                
                if (Math.abs(carSpeed) > 0.2) {
                    const turn = 2.5 * dt * (carSpeed > 0 ? 1 : -1);
                    if (moveLft) currentCar.rotation.y += turn;
                    if (moveRgt) currentCar.rotation.y -= turn;
                }
                
                const moveDist = carSpeed * dt;
                const forwardVector = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), currentCar.rotation.y);
                let collided = false;
                
                const carWidth = 2; const carLength = 4.6;
                const collisionRayOrigin = currentCar.position.clone(); collisionRayOrigin.y = 1; 
                const collisionCheckPoints = [
                    collisionRayOrigin.clone().add(forwardVector.clone().multiplyScalar(carLength / 2 * 0.9)),
                    collisionRayOrigin.clone().add(forwardVector.clone().multiplyScalar(carLength / 2 * 0.9)).add(new THREE.Vector3().set(forwardVector.z, 0, -forwardVector.x).normalize().multiplyScalar(carWidth/2)), 
                    collisionRayOrigin.clone().add(forwardVector.clone().multiplyScalar(carLength / 2 * 0.9)).add(new THREE.Vector3().set(forwardVector.z, 0, -forwardVector.x).normalize().multiplyScalar(-carWidth/2)) 
                ];
                const maxDistance = Math.abs(moveDist) + 5; 

                for(let point of collisionCheckPoints) {
                    carRaycaster.set(point, forwardVector);
                    const hits = carRaycaster.intersectObjects(collisionObjects, false);
                    if (hits.length > 0 && hits[0].distance < maxDistance) {
                        collided = true; carSpeed *= -0.7; 
                        const bounceDir = forwardVector.clone().negate().multiplyScalar(5 * dt); 
                        currentCar.position.add(bounceDir);
                        break;
                    }
                }
                if (!collided) { currentCar.translateZ(-moveDist); }
                currentCar.position.y = 0; 
                if (Math.abs(carSpeed) > 8) { npcs.forEach(npc => { if (npc.position.distanceTo(currentCar.position) < 3) killNPC(npc, true); }); }
                
                const offset = new THREE.Vector3(0, 5, 10); offset.applyMatrix4(currentCar.matrixWorld);
                camera.position.lerp(offset, 0.1); camera.lookAt(currentCar.position);

                // --- –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê –£–†–û–ù–ê –ó–ê –ì–†–ê–ù–ò–¶–ï–ô (–ù–ê –ú–ê–®–ò–ù–ï) ---
                checkBoundaryDamage(currentCar.position, dt);
                // -----------------------------------------------

            } else {
                // –î–≤–∏–∂–µ–Ω–∏–µ –ø–µ—à–µ—Ö–æ–¥–∞, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã–∑—ã–≤–∞–µ—Ç movePlayer(dt)
                movePlayer(dt);
            }

            // --- –õ–û–ì–ò–ö–ê –ü–û–õ–ò–¶–ï–ô–°–ö–û–ô –ú–ê–®–ò–ù–´ ---
            if (wantedLevel > 0 && currentCar && !policeCar) {
                const availableCars = cars.filter(c => c.userData.isPoliceCar && c !== currentCar && !c.userData.isBeingUsedByPolice);
                if (availableCars.length > 0) {
                    policeCar = availableCars[0]; 
                    policeCar.userData.isBeingUsedByPolice = true;
                    policeCar.userData.speed = 0; 
                    policeCar.userData.lastShotTime = performance.now();
                }
            }
            if (policeCar && currentCar) {
                const target = currentCar.position;
                const pCar = policeCar;
                const toTarget = new THREE.Vector3().subVectors(target, pCar.position);
                toTarget.y = 0;
                
                const distance = toTarget.length();
                if (distance < 5) { pCar.userData.speed *= 0.95; endGame(); }

                const angleToTarget = Math.atan2(toTarget.x, toTarget.z);
                const currentAngle = pCar.rotation.y;
                let angleDiff = angleToTarget - currentAngle;

                if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                const steering = Math.sign(angleDiff) * Math.min(Math.abs(angleDiff) * 0.5, 0.05);
                pCar.rotation.y += steering;

                pCar.userData.speed = Math.min(pCar.userData.speed + 15 * dt, 40);
                pCar.translateZ(-pCar.userData.speed * dt); 
                
                policeCarAttack(policeCar, currentCar);
            }
            
            // --- –õ–û–ì–ò–ö–ê NPC: –î–í–ò–ñ–ï–ù–ò–ï, –ü–ê–ù–ò–ö–ê –ò –°–¢–†–ï–õ–¨–ë–ê ---
            const targetPos = currentCar ? currentCar.position : player.position;
            
            npcs.forEach(npc => {
                npc.position.y = 0; 
                let speed = 1.5;
                let targetDir = npc.userData.dir.clone();
                let shouldTurn = false;
                const NPC_BOUNDARY_FUDGE = 20; 

                if (npc.userData.state === 'PANIC') { 
                    speed = 9; 
                    const danger = currentCar ? currentCar.position : player.position; 
                    const runAwayDir = new THREE.Vector3().subVectors(npc.position, danger); 
                    runAwayDir.y = 0;
                    runAwayDir.x += (Math.random() - 0.5) * 0.1; 
                    runAwayDir.z += (Math.random() - 0.5) * 0.1;
                    runAwayDir.normalize();
                    targetDir.lerp(runAwayDir, 0.15); 
                } 
                else if (npc.userData.isPolice && wantedLevel > 0) { 
                    const distance = npc.position.distanceTo(targetPos);

                    if (currentCar) {
                        speed = 0; 
                        npc.lookAt(targetPos);
                    } else {
                        speed = 8; 
                        const toPlayer = new THREE.Vector3().subVectors(targetPos, npc.position).normalize(); 
                        targetDir.lerp(toPlayer, 0.05); 
                        npc.lookAt(targetPos);

                        if (distance < 2) endGame(); 
                        if (distance < 150 && npc.userData.hasWeapon === 'PISTOL') { 
                             npcShoot(npc);
                        }
                    }
                }

                const collisionDist = npc.userData.state === 'PANIC' ? 6 : 4; 
                
                const checkPosAhead = npc.position.clone().add(targetDir.clone().normalize().multiplyScalar(15));
                if (Math.abs(checkPosAhead.x) > MAP_SIZE - NPC_BOUNDARY_FUDGE || Math.abs(checkPosAhead.z) > MAP_SIZE - NPC_BOUNDARY_FUDGE) {
                    shouldTurn = true;
                }
                
                raycaster.set(new THREE.Vector3(npc.position.x, 1, npc.position.z), targetDir);
                const hits = raycaster.intersectObjects(collisionObjects);
                
                if (hits.length > 0 && hits[0].distance < collisionDist) { 
                    shouldTurn = true; 
                } 
                
                if (shouldTurn) {
                    const rotationAngle = Math.PI/3 + Math.random() * Math.PI/3; 
                    targetDir.applyAxisAngle(new THREE.Vector3(0,1,0), rotationAngle); 
                }
                
                npc.userData.dir.copy(targetDir.normalize()); 

                const nextPos = npc.position.clone().add(npc.userData.dir.clone().multiplyScalar(speed * dt));
                
                if (Math.abs(nextPos.x) > MAP_SIZE || Math.abs(nextPos.z) > MAP_SIZE) {
                    npc.userData.dir.applyAxisAngle(new THREE.Vector3(0,1,0), Math.PI + (Math.random()-0.5)*0.5);
                } else {
                    npc.position.copy(nextPos); 
                    if (npc.userData.state !== 'POLICE' || !currentCar) {
                        npc.lookAt(npc.position.clone().add(npc.userData.dir)); 
                    }
                }
            });

            // --- –õ–û–ì–ò–ö–ê –¢–ê–ô–ú–ï–†–ê –†–û–ó–´–°–ö–ê ---
            if (wantedLevel > 0) {
                let isPolicePursuing = policeCar && currentCar;
                
                if (!isPolicePursuing) {
                    const targetPos = currentCar ? currentCar.position : player.position;
                    const pursuingNPCs = npcs.filter(n => 
                        n.userData.isPolice && 
                        n.position.distanceTo(targetPos) < 50 
                    );
                    isPolicePursuing = pursuingNPCs.length > 0;
                }

                if (isPolicePursuing) {
                    wantedDecayTimer = 0;
                } else {
                    wantedDecayTimer += dt;
                    
                    if (wantedDecayTimer >= WANTED_DECAY_TIME) {
                        wantedLevel = Math.max(0, wantedLevel - 1);
                        wantedDecayTimer = 0;
                        updateWantedLevelDisplay();
                        
                        if (wantedLevel === 0) {
                             npcs.forEach(n => { if(n.userData.state === 'PANIC') n.userData.state = 'WALK'; });
                             if (policeCar) {
                                policeCar.userData.isBeingUsedByPolice = false;
                                policeCar = null;
                             }
                        }
                    }
                }
            } else {
                wantedDecayTimer = 0;
            }
            
            updateMiniMap(); 
            updateParticles(); renderer.render(scene, camera);
        }

        // --- –û–°–¢–ê–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò (–ù–µ –∏–∑–º–µ–Ω–µ–Ω—ã, –Ω–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã) ---
        function createMapBounds() {
            const bounds = MAP_SIZE + BORDER_COLLISION_SIZE / 2;
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x808080, 
                opacity: 0.1, 
                transparent: true,
                roughness: 0.9, 
                metalness: 0.1 
            }); 
            const wall1 = new THREE.Mesh(new THREE.BoxGeometry(MAP_SIZE * 2 + BORDER_COLLISION_SIZE * 2, VISIBLE_WALL_HEIGHT, BORDER_COLLISION_SIZE), material); wall1.position.set(0, VISIBLE_WALL_HEIGHT/2, -bounds); collisionObjects.push(wall1); scene.add(wall1);
            const wall2 = new THREE.Mesh(new THREE.BoxGeometry(MAP_SIZE * 2 + BORDER_COLLISION_SIZE * 2, VISIBLE_WALL_HEIGHT, BORDER_COLLISION_SIZE), material); wall2.position.set(0, VISIBLE_WALL_HEIGHT/2, bounds); collisionObjects.push(wall2); scene.add(wall2);
            const wall3 = new THREE.Mesh(new THREE.BoxGeometry(BORDER_COLLISION_SIZE, VISIBLE_WALL_HEIGHT, MAP_SIZE * 2), material); wall3.position.set(-bounds, VISIBLE_WALL_HEIGHT/2, 0); collisionObjects.push(wall3); scene.add(wall3);
            const wall4 = new THREE.Mesh(new THREE.BoxGeometry(BORDER_COLLISION_SIZE, VISIBLE_WALL_HEIGHT, MAP_SIZE * 2), material); wall4.position.set(bounds, VISIBLE_WALL_HEIGHT/2, 0); collisionObjects.push(wall4); scene.add(wall4);
        }
        
        function respawnNPCs() {
            const currentCivs = npcs.filter(n => !n.userData.isPolice).length;
            const currentPolice = npcs.filter(n => n.userData.isPolice).length;
            
            const missingCivs = NPC_COUNT - POLICE_COUNT - currentCivs;
            const missingPolice = POLICE_COUNT - currentPolice;

            if (missingCivs > 0) {
                spawnNPCs(missingCivs, false);
            }
            if (missingPolice > 0) {
                spawnNPCs(missingPolice, true);
            }
        }
        
        function createCity() {
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE * 2 + 100, MAP_SIZE * 2 + 100), new THREE.MeshStandardMaterial({ color: 0xCCCCCC })); ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
            const parkingLot = new THREE.Mesh(new THREE.PlaneGeometry(30, 40), new THREE.MeshStandardMaterial({ color: 0x222222 })); parkingLot.rotation.x = -Math.PI/2; parkingLot.position.set(-15, 0.02, 0); parkingLot.receiveShadow = true; scene.add(parkingLot); 
            const lineGeo = new THREE.PlaneGeometry(0.2, 10); const lineMat = new THREE.MeshBasicMaterial({color: 0xffff00});
            const line1 = new THREE.Mesh(lineGeo, lineMat); line1.rotation.x = -Math.PI/2; line1.position.set(-10, 0.03, -10); scene.add(line1);
            const line2 = new THREE.Mesh(lineGeo, lineMat); line2.rotation.x = -Math.PI/2; line2.position.set(-20, 0.03, -10); scene.add(line2);

            const blockSize = 50;
            for(let x = -MAP_SIZE; x <= MAP_SIZE; x+=blockSize) {
                for(let z = -MAP_SIZE; z <= MAP_SIZE; z+=blockSize) {
                    if (x > -30 && x < 30 && z > -30 && z < 40) continue; 
                    if (Math.abs(x) < MAP_SIZE && Math.abs(z) < MAP_SIZE && (x % 100 === 0 || z % 100 === 0)) {
                            const roadPatch = new THREE.Mesh(new THREE.PlaneGeometry(blockSize, blockSize), new THREE.MeshStandardMaterial({ color: 0x333333 })); roadPatch.rotation.x = -Math.PI/2; roadPatch.position.set(x, 0.01, z); roadPatch.receiveShadow = true; scene.add(roadPatch);
                    }
                    if (Math.abs(x) < MAP_SIZE - 50 && Math.abs(z) < MAP_SIZE - 50 && Math.abs(x) % 100 !== 0 && Math.abs(z) % 100 !== 0) {
                        const h = Math.random() * 25 + 10; const w = blockSize - 15;
                        const building = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshStandardMaterial({ color: 0xDCDCDC, roughness: 0.8 }));
                        building.position.set(x, h/2, z); building.castShadow = true; building.receiveShadow = true; 
                        scene.add(building); 
                        collisionObjects.push(building); 
                        const roof = new THREE.Mesh(new THREE.ConeGeometry(w/1.5, 4, 4), new THREE.MeshStandardMaterial({color: Math.random()>0.5?0x8b0000:0x2e8b57})); roof.position.set(x, h + 2, z); roof.rotation.y = Math.PI/4; roof.castShadow = true; scene.add(roof);
                        
                        mapBuildings.push({x: x, z: z, w: w, d: w});
                    }
                    else if (Math.abs(x) > MAP_SIZE - 50 || Math.abs(z) > MAP_SIZE - 50) {
                            if (Math.random() > 0.95) createTree(x + Math.random()*10, z + Math.random()*10); 
                    }
                }
            }
        }
        function createStreetFurniture() {
            createBench(-40, 0.01, 5, 0); 
            createBench(-100, 0.01, -5, 0);
        }
        function createTree(x, z) {
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 3), new THREE.MeshStandardMaterial({color:0x5c4033})); trunk.position.set(x, 1.5, z); trunk.castShadow = true; scene.add(trunk); collisionObjects.push(trunk);
            const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(2.5), new THREE.MeshStandardMaterial({color:0x228b22})); leaves.position.set(x, 4, z); leaves.castShadow = true; scene.add(leaves);
        }
        function createCarMesh(color, isPolice) {
            const group = new THREE.Group();
            const bodyColor = isPolice ? 0x0000FF : color; 
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.7, 4.6), new THREE.MeshStandardMaterial({color: bodyColor})); body.position.y = 0.6; body.castShadow = true; group.add(body);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.6, 2.5), new THREE.MeshStandardMaterial({color: 0x111111})); cabin.position.set(0, 1.2, -0.1); cabin.castShadow = true; group.add(cabin);
            const wMat = new THREE.MeshStandardMaterial({color: 0x000000});
            const wGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.4, 16); wGeo.rotateZ(Math.PI/2);
            [[1.1,1.5],[-1.1,1.5],[1.1,-1.5],[-1.1,-1.5]].forEach(p=>{
                const w=new THREE.Mesh(wGeo,wMat); w.position.set(p[0],0.45,p[1]); group.add(w);
            });
            
            if (isPolice) {
                const light = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.1, 0.3), new THREE.MeshBasicMaterial({color: 0xFF0000, transparent: true, opacity: 0.8}));
                light.position.set(0, 1.5, 0.8);
                group.add(light);
            }

            group.userData = { speed: 0, steering: 0, isPoliceCar: isPolice, isBeingUsedByPolice: false, lastShotTime: 0 };
            return group;
        }
        function getRandomMapPosition() {
            let x = (Math.random()-0.5) * MAP_SIZE * 2 * 0.9; 
            let z = (Math.random()-0.5) * MAP_SIZE * 2 * 0.9;
            return {x, z};
        }
        
        function spawnParkingLotCars() {
            const spawnCars = [
                { color: 0xff0000, isPolice: false, x: -10, z: 0 },
                { color: 0x00FF00, isPolice: false, x: -15, z: 0 },
                { color: 0, isPolice: true, x: -20, z: 0 }
            ];

            spawnCars.forEach(sc => {
                const car = createCarMesh(sc.color, sc.isPolice);
                car.position.set(sc.x, 0, sc.z);
                car.rotation.y = Math.PI / 2;
                car.castShadow = true;
                cars.push(car);
                scene.add(car);
                collisionObjects.push(car.children[0]);
            });
        }
        
        function spawnTraffic() {
            for(let i=0; i<TRAFFIC_CAR_COUNT; i++) {
                const isPolice = Math.random() < 0.1; 
                const car = createCarMesh(Math.random()*0xffffff, isPolice);
                
                let x, z;
                do {
                    x = (Math.random()-0.5) * MAP_SIZE * 2 * 0.9; 
                    z = (Math.random()-0.5) * MAP_SIZE * 2 * 0.9;
                } while (Math.abs(x) < 30 && Math.abs(z) < 30); 
                
                car.position.set(x, 0, z); 
                car.rotation.y = Math.random() * Math.PI * 2; 
                car.castShadow = true; 
                scene.add(car); 
                cars.push(car); 
                collisionObjects.push(car.children[0]);
            }
        }
        
        function spawnNPCs(count, isPolice) {
            for(let i=0; i<count; i++) {
                const group = new THREE.Group();
                const bodyColor = isPolice ? 0x000088 : Math.random()*0xffffff;
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.5, 0.3), new THREE.MeshStandardMaterial({color: bodyColor})); body.position.y = 0.75; body.castShadow = true;
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.25), new THREE.MeshStandardMaterial({color: 0xffe0bd})); head.position.y = 1.6; head.castShadow = true;
                group.add(body); group.add(head);
                const {x, z} = getRandomMapPosition();
                group.position.set(x, 0, z); group.castShadow = true;
                group.userData = { isPolice: isPolice, hp: 100, state: 'WALK', dir: new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).normalize(), hasWeapon: isPolice ? 'PISTOL' : 'FIST' };
                scene.add(group); npcs.push(group);
            }
        }
        
        function tryEnterCar() {
            if (currentCar) {
                player.position.copy(currentCar.position); 
                player.position.x -= 3; 
                player.position.y = CAMERA_HEIGHT; 
                player.userData.canJump = true; 
                player.userData.velocityY = 0;
                player.visible = true; 
                player.add(camera); 
                camera.position.set(0,0,0); 
                camera.rotation.set(0,0,0); 
                currentCar = null; 
                document.getElementById('crosshair').style.display = 'block'; 
                document.getElementById('weaponDisplay').style.display = 'block'; 
                weaponGroup.visible = true;
            } else {
                let closest = null; let minD = 5;
                cars.forEach(c => { const d = player.position.distanceTo(c.position); if(d<minD){ minD=d; closest=c; }});
                if (closest && !closest.userData.isBeingUsedByPolice) { 
                    currentCar = closest; 
                    player.visible = false; 
                    scene.add(camera); 
                    document.getElementById('crosshair').style.display = 'none'; 
                    document.getElementById('weaponDisplay').style.display = 'none'; 
                    document.getElementById('carHint').style.display = 'none'; 
                    weaponGroup.visible = false; 
                    carSpeed = 0;
                }
            }
        }
        function killNPC(npc, byCar) { 
            createBlood(npc.position); 
            if(byCar) playSound('hit'); 
            
            if (npc.userData.isPolice) {
                 wantedLevel = Math.min(wantedLevel + 3, 5);
                 if (policeCar && policeCar.userData.isBeingUsedByPolice) policeCar = null; 
            } else {
                 wantedLevel = Math.min(wantedLevel + 1, 5);
            }
            
            wantedDecayTimer = 0; 
            updateWantedLevelDisplay();

            scene.remove(npc); 
            npcs.splice(npcs.indexOf(npc), 1); 
            npcs.forEach(n => { if(!n.userData.isPolice) n.userData.state = 'PANIC'; }); 
        }
        function createBlood(pos) { for(let k=0; k<8; k++) { const m = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color:0x880000})); m.position.copy(pos); m.position.x+=(Math.random()-0.5); m.position.z+=(Math.random()-0.5); m.position.y=0.1; scene.add(m); particles.push({mesh:m, life:100}); } }
        function updateParticles() { for(let i=particles.length-1; i>=0; i--) { particles[i].life--; if(particles[i].life<=0) { scene.remove(particles[i].mesh); particles.splice(i,1); } } }
        function createWeapons() { weaponGroup = new THREE.Group(); camera.add(weaponGroup); weaponGroup.position.set(0.3, -0.4, -0.5); const fist = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshStandardMaterial({color: 0xffccaa})); fist.name = 'FIST'; weaponGroup.add(fist); const gun = new THREE.Group(); gun.visible = false; gun.name = 'PISTOL'; gun.add(new THREE.Mesh(new THREE.BoxGeometry(0.08,0.08,0.4), new THREE.MeshStandardMaterial({color:0x111111}))); weaponGroup.add(gun); }
        
        function onKeyDown(e) { 
            if(e.code==='KeyW') moveFwd=true; 
            if(e.code==='KeyS') moveBwd=true; 
            if(e.code==='KeyA') moveLft=true; 
            if(e.code==='KeyD') moveRgt=true; 
            if(e.code==='KeyF') tryEnterCar(); 
            
            if (e.code === 'Space' && player.userData.canJump && !currentCar) { 
                player.userData.velocityY = 10; 
                player.userData.canJump = false; 
            }
            
            if(e.code==='Digit1'&&!currentCar) { currentWeapon='FIST'; weaponGroup.children[0].visible=true; weaponGroup.children[1].visible=false; document.getElementById('weaponDisplay').innerText='üëä –ö–£–õ–ê–ö–ò'; } 
            if(e.code==='Digit2'&&!currentCar) { currentWeapon='PISTOL'; weaponGroup.children[0].visible=false; weaponGroup.children[1].visible=true; document.getElementById('weaponDisplay').innerText='üî´ –ü–ò–°–¢–û–õ–ï–¢'; } 
        }

        function onKeyUp(e) { 
            if(e.code==='KeyW') moveFwd=false; 
            if(e.code==='KeyS') moveBwd=false; 
            if(e.code==='KeyA') moveLft=false; 
            if(e.code==='KeyD') moveRgt=false; 
        }
        function onMouseMove(e) { if(currentCar||document.pointerLockElement!==document.body) return; player.rotation.y -= e.movementX*0.002; camera.rotation.x -= e.movementY*0.002; camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x)); }
        
        function onMouseDown() { 
            if(!isGameActive) return; 
            if(currentCar) return; 
            if(document.pointerLockElement!==document.body) { document.body.requestPointerLock(); return; } 
            
            if (currentWeapon === 'PISTOL') {
                camera.rotation.x -= 0.05; 
                setTimeout(() => {
                    camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x + 0.05));
                }, 100);
            }
            
            playSound(currentWeapon==='FIST'?'punch':'shoot'); 
            weaponGroup.position.z = -0.2; setTimeout(()=>weaponGroup.position.z=-0.5, 100); 
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera); 
            const hits = raycaster.intersectObjects(npcs, true); 
            
            if(hits.length > 0) { 
                const d = hits[0].distance; 
                if(d < (currentWeapon==='FIST'?3:150)) { 
                    let t = hits[0].object; 
                    while(t.parent && t.parent.type!=='Scene') t=t.parent; 
                    
                    t.userData.hp -= (currentWeapon==='FIST'?50:100); 
                    
                    if(t.userData.hp<=0) killNPC(t, false); 
                    else { 
                        npcs.forEach(n => { if(!n.userData.isPolice) n.userData.state = 'PANIC'; });
                        wantedLevel = Math.min(wantedLevel+1, 5); 
                        wantedDecayTimer = 0; 
                        updateWantedLevelDisplay(); 
                    } 
                } 
            } 
        }

        function endGame() { 
            isGameActive = false; 
            document.exitPointerLock(); 
            const bustedScreen = document.getElementById('bustedScreen');
            
            bustedScreen.querySelector('h1').innerText = "üíÄ –¢–´ –£–ú–ï–† üíÄ"; 
            bustedScreen.querySelector('h2').innerText = "–ê –Ø –ì–û–í–û–†–ò–õ –¢–ï–ë–ï –≠–• –õ–Å–•–ê.";
            bustedScreen.querySelector('button').innerText = "–ù–ê–ß–ê–¢–¨ –°–ù–û–í–ê";
            
            bustedScreen.style.display = 'flex'; 
        }

        document.getElementById('startBtn').addEventListener('click', () => { 
            document.getElementById('menu').style.display = 'none'; 
            init(); 
            isGameActive = true; 
            document.body.requestPointerLock(); 
            document.getElementById('hpDisplay').innerText = `‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: ${playerHP}`;
            updateWantedLevelDisplay();
        });

        document.getElementById('help-btn').addEventListener('click', () => {
             document.getElementById('infoBox').style.display = 'block';
        });
        
        function playSound(name) {
             const osc = audioCtx.createOscillator();
             const gain = audioCtx.createGain();
             osc.connect(gain);
             gain.connect(audioCtx.destination);

             switch(name) {
                case 'punch':
                    osc.type = 'square'; osc.frequency.setValueAtTime(50, audioCtx.currentTime); gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                    break;
                case 'shoot':
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(800, audioCtx.currentTime); gain.gain.setValueAtTime(0.7, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
                    break;
                default: 
                    return;
             }
             osc.start(); osc.stop(audioCtx.currentTime + 0.2);
        }
    </script>
</body>
</html>