<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTA –õ–Å–•–ê (V12.9 - –ü–†–´–ñ–ö–ò –ò –†–û–ó–´–°–ö-–¢–ê–ô–ú–ï–†)</title>
    <style>
        /* --- –°–¢–ò–õ–ò --- */
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; user-select: none; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }

        /* CROSSHAIR */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><circle cx="10" cy="10" r="2" fill="white" stroke="black"/><path d="M10,0 L10,6 M10,14 L10,20 M0,10 L6,10 M14,10 L20,10" stroke="black" stroke-width="1"/></svg>') no-repeat center;
            transform: translate(-50%, -50%); z-index: 10; pointer-events: none;
        }

        /* HUD */
        #hud {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            text-align: right; color: white; text-shadow: 2px 2px 2px #000; font-weight: bold;
        }
        
        #carHint {
            position: absolute; bottom: 20%; width: 100%; text-align: center;
            color: #ffff00; font-size: 2em; text-shadow: 2px 2px 4px black; display: none;
            animation: bounce 1s infinite;
        }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }

        /* BOUNDARY WARNING */
        #boundaryWarning {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; justify-content: center; align-items: center;
            background: rgba(255, 0, 0, 0.4); 
            color: white; font-size: 4em; font-weight: bold;
            text-shadow: 0 0 10px black;
            z-index: 50; 
            pointer-events: none;
            text-align: center;
            padding: 20px;
        }

        /* --- –ú–ò–ù–ò-–ö–ê–†–¢–ê --- */
        #miniMap {
            position: absolute; bottom: 20px; left: 20px; z-index: 10;
            width: 200px; height: 200px; 
            background: #888888; 
            border: 3px solid white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        #mapContent {
            position: absolute;
            width: 200px;
            height: 200px;
            transform-origin: 50% 50%; 
        }

        /* –ú–∞—Ä–∫–µ—Ä—ã –∏ —ç–ª–µ–º–µ–Ω—Ç—ã 2D –∫–∞—Ä—Ç—ã */
        .mapMarker {
            position: absolute;
            width: 8px; height: 8px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        /* --- –ú–∞—Ä–∫–µ—Ä –∏–≥—Ä–æ–∫–∞ (—É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π) --- */
        #playerMarker { 
            background-color: lime; 
            border: 2px solid white; 
            z-index: 5; 
            width: 12px; 
            height: 12px;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.8); 
        }
        /* ----------------------------------- */
        .policeMarker { background-color: red; border: 1px solid black; z-index: 4; }
        .mapBuilding {
            position: absolute;
            background-color: #228b22; 
            border: 1px solid #000;
            box-sizing: border-box;
            opacity: 0.8;
        }

        /* --- –ú–ï–ù–Æ (–ú–ê–ö–°–ò–ú–ê–õ–¨–ù–û –ö–†–ê–°–ò–í–û–ï) --- */
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #0d0d0d; /* –ì–ª—É–±–æ–∫–∏–π —Ç–µ–º–Ω—ã–π —Ñ–æ–Ω */
            background-image: radial-gradient(circle, #333 1px, transparent 1px);
            background-size: 30px 30px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: white;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
        }

        #menu h1 { 
            font-size: 7.5em; 
            color: #ff0055; /* –ù–µ–æ–Ω–æ–≤–æ-–∫—Ä–∞—Å–Ω—ã–π */
            margin: 0; 
            font-family: 'Arial Black', sans-serif;
            letter-spacing: 12px;
            /* –ù–µ–æ–Ω–æ–≤–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ */
            text-shadow: 
                0 0 10px #ff0055,
                0 0 20px #ff0055,
                0 0 40px #00ffff; /* –ì–æ–ª—É–±–æ–π –∞–∫—Ü–µ–Ω—Ç */
            animation: neonPulse 1.5s infinite alternate; 
        }
        @keyframes neonPulse {
            from { transform: scale(1); opacity: 0.9; }
            to { transform: scale(1.03); opacity: 1; }
        }
        
        #menu #subtitle {
            font-size: 1.8em; 
            color: #00ffaa; /* –≠–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–∏–π –∑–µ–ª–µ–Ω—ã–π –∞–∫—Ü–µ–Ω—Ç */
            text-shadow: 0 0 5px #00ffaa;
            margin-top: 20px;
            margin-bottom: 50px;
        }

        #menu button {
            background: #111;
            color: white;
            border: 2px solid #ff0055; /* –ù–µ–æ–Ω–æ–≤–æ-–∫—Ä–∞—Å–Ω–∞—è —Ä–∞–º–∫–∞ */
            padding: 15px 35px;
            font-size: 1.6em;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 0, 85, 0.5); /* –ù–∞—á–∞–ª—å–Ω–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ */
            letter-spacing: 2px;
        }
        #menu button:hover {
            background: #ff0055;
            color: black;
            border-color: #00ffff; /* –°–º–µ–Ω–∞ —Ü–≤–µ—Ç–∞ —Ä–∞–º–∫–∏ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ */
            box-shadow: 0 0 20px #ff0055, 0 0 40px #00ffff; /* –£—Å–∏–ª–µ–Ω–Ω–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ */
            transform: scale(1.05); 
        }
        
        /* BUSTED SCREEN (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π) */
        #bustedScreen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); color: red;
            flex-direction: column; justify-content: center; align-items: center; z-index: 100;
        }
        #bustedScreen h1 {
            font-family: Impact; letter-spacing: 5px; color: red;
            font-size: 6em;
            text-shadow: 0 0 15px white, 0 0 30px red;
        }
        #bustedScreen h2 {
            font-size: 2.5em; color: #fff; margin-top: 10px;
        }
        
        /* HELP BOX */
        #infoBox {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 5px solid #ff0055;
            padding: 40px;
            color: white;
            font-size: 1.2em;
            text-align: left;
            z-index: 101;
            display: none;
            box-shadow: 0 0 30px #ff0055;
            max-width: 600px;
        }
        #infoBox button {
            margin-top: 20px;
            background: #ff0055;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 1em;
            display: block;
            width: 100%;
        }
        #infoBox h3 {
            text-align: center;
            color: #00ffff;
            border-bottom: 2px solid #ff0055;
            padding-bottom: 10px;
        }
        #infoBox p, #infoBox ul {
             margin-bottom: 15px;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="carHint">–ù–ê–ñ–ú–ò–¢–ï [F], –ß–¢–û–ë–´ –°–ï–°–¢–¨ –í –ú–ê–®–ò–ù–£</div>
    <div id="boundaryWarning"></div>
    
    <div id="hud">
        <div id="timeDisplay">12:00</div>
        <div id="hpDisplay" style="color: red; margin-top: 5px;"‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: 100</div>
        <div id="weaponDisplay" style="color: orange; margin-top: 5px;">üëä –ö–£–õ–ê–ö–ò</div>
        <div id="wantedLevel" style="color: white; margin-top: 5px;">‚òÖ –†–û–ó–´–°–ö: 0</div>
        <div id="wantedLevelTimer" style="color: #00ffff; margin-top: 2px; font-size: 0.9em; display: none;"></div>
        <div style="font-size: 0.8em; color: #ffff00; margin-top:10px;">V12.9 (–ü–†–´–ñ–ö–ò, –¢–ï–ù–ò, –¢–ê–ô–ú–ï–†)</div>
    </div>
    
    <div id="miniMap">
        <div id="mapContent">
             <div id="playerMarker" class="mapMarker" style="left: 50%; top: 50%;"></div>
        </div>
    </div>

    <div id="menu">
        <div>
            <span class="bomb-emoji" style="font-size: 3em; margin-right: 20px; text-shadow: 0 0 5px #ff0055;">üö®</span>
            <h1>GTA –õ–Å–•–ê</h1>
            <span class="bomb-emoji" style="font-size: 3em; margin-left: 20px; text-shadow: 0 0 5px #00ffff;">üöì</span>
        </div>
        <div id="subtitle">–°–ê–ú–´–ô –ö–†–ò–ú–ò–ù–ê–õ–¨–ù–´–ô –°–ò–ú–£–õ–Ø–¢–û–†</div>
        <p style="margin-top: 30px; font-size: 1.2em; color: #aaa; text-shadow: 1px 1px black;">–°–û–ó–î–ê–ù–û –¢–ò–ú–£–†–û–ú</p>
        <div class="menu-options">
            <button id="startBtn">–ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button>
            <button id="help-btn">–ü–û–ú–û–©–¨</button>
        </div>
    </div>

    <div id="infoBox">
        <h3>–ü–û–ú–û–©–¨: GTA –õ–Å–•–ê</h3>

        <h4>üìñ –°—é–∂–µ—Ç –∏ –°–º—ã—Å–ª</h4>
        <p>–¢—ã, –õ—ë—Ö–∞, ‚Äî –∫—Ä—É—Ç–æ–π —á—É–≤–∞–∫ –≤ –±–æ–ª—å—à–æ–º –≥–æ—Ä–æ–¥–µ, –∫–æ—Ç–æ—Ä—ã–π –≤—Å–µ–≥–¥–∞ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ –∫–∞–∫–∏–µ-—Ç–æ –ø–µ—Ä–µ–¥—Ä—è–≥–∏. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî **–≤—ã–∂–∏—Ç—å, –ø–æ–¥–Ω—è—Ç—å —É—Ä–æ–≤–µ–Ω—å —Ä–æ–∑—ã—Å–∫–∞ –∏ –∏–∑–±–µ–≥–∞—Ç—å –º–µ–Ω—Ç–æ–≤!**</p>
        <p>**–í–ù–ò–ú–ê–ù–ò–ï:** –ù–µ –ª–µ–∑—å –∑–∞ –∫—Ä–∞—Å–Ω—É—é —á–µ—Ä—Ç—É, —ç—Ç–æ –±–æ–ª—å–Ω–æ!</p>

        <h4>üéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h4>
        <ul>
            <li>**WASD:** –î–≤–∏–∂–µ–Ω–∏–µ (—Ö–æ–¥—å–±–∞/–µ–∑–¥–∞)</li>
            <li>**–ú—ã—à—å:** –û–±–∑–æ—Ä/–ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã</li>
            <li>**–õ–ö–ú (–õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏):** –£–¥–∞—Ä / –í—ã—Å—Ç—Ä–µ–ª</li>
            <li>**F:** –°–µ—Å—Ç—å –≤ –º–∞—à–∏–Ω—É / –í—ã–π—Ç–∏ –∏–∑ –º–∞—à–∏–Ω—ã</li>
            <li>**–ü–†–û–ë–ï–õ (Space):** **–ü—Ä—ã–∂–æ–∫**</li>
            <li>**1:** –í—ã–±—Ä–∞—Ç—å **–ö—É–ª–∞–∫–∏** üëä</li>
            <li>**2:** –í—ã–±—Ä–∞—Ç—å **–ü–∏—Å—Ç–æ–ª–µ—Ç** üî´</li>
        </ul>

        <h4>üö® –†–æ–∑—ã—Å–∫ –∏ –ü–æ–ª–∏—Ü–∏—è</h4>
        <p>–ö–∞–∂–¥–æ–µ —É–±–∏–π—Å—Ç–≤–æ (–ø–µ—à–µ—Ö–æ–¥–∞ –∏–ª–∏ –ø–æ–ª–∏—Ü–µ–π—Å–∫–æ–≥–æ) –ø–æ–≤—ã—à–∞–µ—Ç —É—Ä–æ–≤–µ–Ω—å —Ä–æ–∑—ã—Å–∫–∞ (‚òÖ). –ü–æ–ª–∏—Ü–∏—è —Ç–µ–ø–µ—Ä—å —Å—Ç—Ä–µ–ª—è–µ—Ç –∏–∑–¥–∞–ª–µ–∫–∞, –∞ –≤ –º–∞—à–∏–Ω–µ –±—É–¥–µ—Ç –≤–∞—Å **–ø—Ä–µ—Å–ª–µ–¥–æ–≤–∞—Ç—å –∏ –æ–±—Å—Ç—Ä–µ–ª–∏–≤–∞—Ç—å**! –ü–æ–ª–∏—Ü–µ–π—Å–∫–∏—Ö —Å—Ç–∞–ª–æ –±–æ–ª—å—à–µ ‚Äî –±—É–¥—å –æ—Å—Ç–æ—Ä–æ–∂–µ–Ω!</p>
        <p><strong>–ù–û–í–ò–ù–ö–ê:</strong> –†–æ–∑—ã—Å–∫ —Å–ø–∞–¥–∞–µ—Ç —á–µ—Ä–µ–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è, –µ—Å–ª–∏ –≤—ã –Ω–µ —Å–æ–≤–µ—Ä—à–∞–µ—Ç–µ –ø—Ä–µ—Å—Ç—É–ø–ª–µ–Ω–∏–π –∏ –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –∑–æ–Ω–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø–æ–ª–∏—Ü–∏–∏.</p>

        <button onclick="document.getElementById('infoBox').style.display='none'">–ó–ê–ö–†–´–¢–¨</button>
    </div>

    <div id="bustedScreen">
        <h1>–ü–û–ô–ú–ê–ù</h1>
        <h2>–®–û –¢–£–¢ –î–£–ú–ê–õ –í –°–ö–ê–ó–ö–£ –ü–û–ü–ê–õ</h2>
        <button onclick="location.reload()" style="background: red; border-color: #ff3333;">–ü–û–í–¢–û–†–ò–¢–¨</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // === –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø GTA LITE 3D (V12.9) ===
        const CAMERA_HEIGHT = 1.5;
        const NPC_COUNT = 200;       
        const POLICE_COUNT = 20;     
        const TRAFFIC_CAR_COUNT = 15;
        const RESPAWN_INTERVAL = 90 * 1000; 
        const MAP_SIZE = 400; 
        const BORDER_COLLISION_SIZE = 5; 
        const VISIBLE_WALL_HEIGHT = 1; 
        const PLAYER_COLLISION_RADIUS = 1.5; 
        const MINIMAP_SIZE_PX = 200; 
        const MINIMAP_SCALE = 0.8; 
        const MAP_VIEW_RADIUS = MINIMAP_SIZE_PX / MINIMAP_SCALE / 2; 
        const BOUNDARY_RANGE = 50; 
        const BOUNDARY_DAMAGE_AREA = MAP_SIZE - BOUNDARY_RANGE;
        const WANTED_DECAY_TIME = 15; // –°–µ–∫—É–Ω–¥ –Ω–∞ –ø–æ–Ω–∏–∂–µ–Ω–∏–µ 1 —É—Ä–æ–≤–Ω—è —Ä–æ–∑—ã—Å–∫–∞
        
        // === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
        let scene, camera, renderer;
        let player, weaponGroup;
        let raycaster;
        
        const collisionObjects = [];
        const npcs = [];
        const cars = [];
        const particles = [];
        const mapBuildings = []; 
        
        let isGameActive = false;
        let currentCar = null;
        let moveFwd=false, moveBwd=false, moveLft=false, moveRgt=false;
        let prevTime = performance.now();
        
        let wantedLevel = 0;
        let playerHP = 100; 
        let currentWeapon = 'FIST';
        let gameTime = 10;
        let carSpeed = 0;
        let wantedDecayTimer = 0; // –¢–∞–π–º–µ—Ä –¥–ª—è –ø–æ–Ω–∏–∂–µ–Ω–∏—è —Ä–æ–∑—ã—Å–∫–∞
        
        const carRaycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(), 0, 10);
        
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let policeCar = null;
        
        // --- –ü–õ–ï–ô–°–•–û–õ–î–ï–†–´ –î–õ–Ø –ù–ï–î–û–°–¢–ê–Æ–©–ò–• –§–£–ù–ö–¶–ò–ô ---
        function createCity() { console.log("Creating city..."); /* –†–µ–∞–ª—å–Ω—ã–π –∫–æ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≥–æ—Ä–æ–¥–∞ */ }
        function createStreetFurniture() { console.log("Creating street furniture..."); }
        function createMapBounds() { console.log("Creating map bounds..."); }
        function spawnTraffic() { console.log("Spawning traffic..."); }
        function updateTraffic(car, dt) { /* –õ–æ–≥–∏–∫–∞ —Ç—Ä–∞—Ñ–∏–∫–∞ */ }
        function updateNPC(npc, dt) { /* –õ–æ–≥–∏–∫–∞ NPC */ }
        function respawnNPCs() { console.log("Respawning NPCs..."); }
        function createWeapons() { 
            weaponGroup = new THREE.Group();
            const gun = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.2), new THREE.MeshStandardMaterial({color: 0x333333}));
            gun.position.set(0.2, -0.4, -0.4);
            weaponGroup.add(gun);
            player.add(weaponGroup);
        }
        function createCarMesh(color, isPolice) {
            const carGroup = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1.2, 4.6), new THREE.MeshStandardMaterial({color: color, flatShading: true}));
            body.position.y = 0.6;
            body.castShadow = true;
            carGroup.add(body);
            carGroup.userData = { isPolice: isPolice, hp: 100, lastShotTime: 0 };
            return carGroup;
        }
        function createBuilding(x, z, w, d, h) {
            const geometry = new THREE.BoxGeometry(w, h, d);
            const material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, flatShading: true });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, h / 2, z);
            mesh.receiveShadow = true;
            mesh.castShadow = true;
            scene.add(mesh);
            collisionObjects.push(mesh);
            mapBuildings.push({ x: x, z: z, w: w, d: d });
        }
        function createStreetSegment(x, z, w, d) {
            const geometry = new THREE.PlaneGeometry(w, d);
            const material = new THREE.MeshStandardMaterial({ color: 0x555555, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.set(x, 0.01, z);
            mesh.receiveShadow = true;
            scene.add(mesh);
        }
        function createGround(w, d) {
            const geometry = new THREE.PlaneGeometry(w, d);
            const material = new THREE.MeshStandardMaterial({ color: 0x228b22, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            mesh.receiveShadow = true;
            scene.add(mesh);
        }
        // ... (end of placeholders for missing Three.js functions)
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 300);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            player = new THREE.Group();
            player.add(camera);
            player.position.set(0, CAMERA_HEIGHT, 0); 
            // --- –î–û–ë–ê–í–õ–Ø–ï–ú –ü–ï–†–ï–ú–ï–ù–ù–´–ï –î–õ–Ø –ü–†–´–ñ–ö–ê ---
            player.userData = { canJump: true, velocityY: 0 }; 
            scene.add(player);

            createWeapons();
            
            const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambLight);
            const sunLight = new THREE.DirectionalLight(0xffeebb, 0.9);
            sunLight.position.set(50, 150, 100);
            sunLight.castShadow = true;
            // --- –£–õ–£–ß–®–ï–ù–ò–ï –ö–ê–ß–ï–°–¢–í–ê –¢–ï–ù–ï–ô ---
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.near = 1;
            sunLight.shadow.camera.far = 300;
            sunLight.shadow.camera.left = -300;
            sunLight.shadow.camera.right = 300;
            sunLight.shadow.camera.top = 300;
            sunLight.shadow.camera.bottom = -300;
            scene.add(sunLight);

            createCity();
            createStreetFurniture();
            
            createMapBounds(); 
            
            createEasterEggPullUp(150, 150, Math.PI); 
            createEasterEggPullUp(-150, -150, 0); 
            
            spawnParkingLotCars(); 
            
            spawnTraffic();
            
            spawnNPCs(POLICE_COUNT, true);
            spawnNPCs(NPC_COUNT - POLICE_COUNT, false);
            
            setInterval(respawnNPCs, RESPAWN_INTERVAL); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // –ë–æ–ª–µ–µ –º—è–≥–∫–∏–µ —Ç–µ–Ω–∏
            
            // --- –ì–ê–†–ê–ù–¢–ò–Ø –î–û–ë–ê–í–õ–ï–ù–ò–Ø CANVAS –í DOM ---
            const canvasElement = renderer.domElement;
            if (document.body.contains(canvasElement)) {
                 document.body.removeChild(canvasElement);
            }
            document.body.appendChild(canvasElement);
            // ---------------------------------------------------------------------

            raycaster = new THREE.Raycaster();
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }
        
        // --- –û–ë–ù–û–í–õ–ï–ù–ò–ï –û–¢–û–ë–†–ê–ñ–ï–ù–ò–Ø –†–û–ó–´–°–ö–ê ---
        function updateWantedLevelDisplay() {
            const levelText = '‚òÖ'.repeat(wantedLevel);
            document.getElementById('wantedLevel').innerText = `‚òÖ –†–û–ó–´–°–ö: ${wantedLevel} ${levelText}`;
        }
        
        // --- –ü–õ–ï–ô–°–•–û–õ–î–ï–†–´ –î–õ–Ø –î–†–£–ì–ò–• –§–£–ù–ö–¶–ò–ô, –ö–û–¢–û–†–´–ï –ë–´–õ–ò –û–ë–†–ï–ó–ê–ù–´ –í –ö–û–î–ï V12.9 ---
        // (–û–Ω–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã –¥–ª—è —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–æ–π –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏, —Ç–∞–∫ –∫–∞–∫ animate() –≤—ã–∑—ã–≤–∞–µ—Ç –∏—Ö)
        function createEasterEggPullUp(x, z, rotY) { /* ... */ }
        function createBench(x, y, z, rotY) { /* ... */ }
        function spawnParkingLotCars() { /* ... */ }
        function spawnNPCs(count, isPolice) { /* ... */ }
        function killNPC(npc, isCarKill) { /* ... */ }
        function playSound(name) { /* ... */ }
        function endGame() { /* ... */ }

        function movePlayer(dt) {
            const speed = 8; const dir = new THREE.Vector3();
            if (moveFwd) dir.z -= 1; if (moveBwd) dir.z += 1; if (moveLft) dir.x -= 1; if (moveRgt) dir.x += 1;
            dir.normalize().multiplyScalar(speed * dt);
            
            const moveVector = dir.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
            
            // --- –õ–û–ì–ò–ö–ê –ü–†–´–ñ–ö–ê –ò –ì–†–ê–í–ò–¢–ê–¶–ò–ò ---
            player.userData.velocityY -= 9.8 * dt * 2; // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é (—É—Å–∫–æ—Ä–µ–Ω–Ω—É—é)
            player.position.y += player.userData.velocityY * dt;
            
            if (player.position.y < CAMERA_HEIGHT) {
                player.position.y = CAMERA_HEIGHT;
                player.userData.canJump = true;
                player.userData.velocityY = 0;
            }
            // ----------------------------------
            
            const newPos = player.position.clone();
            newPos.x += moveVector.x;
            newPos.z += moveVector.z;
            newPos.y = CAMERA_HEIGHT; // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Ç–æ–ª—å–∫–æ –Ω–∞ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –∑–µ–º–ª–∏

            let collided = false;

            for(let obj of collisionObjects) {
                const oPos = new THREE.Vector3();
                obj.updateWorldMatrix(true, false);
                oPos.setFromMatrixPosition(obj.matrixWorld); 
                oPos.y = 0;

                let isBuilding = obj.geometry.type === 'BoxGeometry' && obj.geometry.parameters.width > 10;

                if (isBuilding) { 
                    const w = obj.geometry.parameters.width / 2;
                    const d = obj.geometry.parameters.depth / 2;
                    const cushion = PLAYER_COLLISION_RADIUS;

                    if (
                        newPos.x > oPos.x - w - cushion && newPos.x < oPos.x + w + cushion &&
                        newPos.z > oPos.z - d - cushion && newPos.z < oPos.z + d + cushion
                    ) {
                        const overlapX = Math.min(newPos.x - (oPos.x - w), (oPos.x + w) - newPos.x);
                        const overlapZ = Math.min(newPos.z - (oPos.z - d), (oPos.z + d) - newPos.z);
                        
                        let push = new THREE.Vector3();
                        if (overlapX < overlapZ) {
                            const dirX = newPos.x > oPos.x ? 1 : -1;
                            push.x = dirX * (cushion - overlapX);
                        } else {
                            const dirZ = newPos.z > oPos.z ? 1 : -1;
                            push.z = dirZ * (cushion - overlapZ);
                        }

                        player.position.x += push.x;
                        player.position.z += push.z;
                        dir.set(0, 0, 0); 
                        collided = true;
                        break;
                    }
                } else if (newPos.distanceTo(oPos) < PLAYER_COLLISION_RADIUS) { 
                    const push = newPos.clone().sub(oPos).normalize().multiplyScalar(PLAYER_COLLISION_RADIUS - newPos.distanceTo(oPos)); 
                    player.position.x += push.x;
                    player.position.z += push.z;
                    dir.set(0, 0, 0); 
                    collided = true;
                    break;
                }
            }

            if (!collided) {
                player.translateX(dir.x); 
                player.translateZ(dir.z); 
            }
            
            // --- –õ–û–ì–ò–ö–ê –£–†–û–ù–ê –ó–ê –ì–†–ê–ù–ò–¶–ï–ô ---
            const boundaryWarning = document.getElementById('boundaryWarning');
            let isOutOfBounds = Math.abs(player.position.x) > BOUNDARY_DAMAGE_AREA || Math.abs(player.position.z) > BOUNDARY_DAMAGE_AREA;
            
            if (isOutOfBounds) {
                 boundaryWarning.style.display = 'flex';
                 boundaryWarning.innerText = "üõë –õ–Å–•–ê –î–£–†–ê–ß–û–ö –ù–ï –õ–ï–ó–¨ –¢–£–î–ê (–°–í–û–ë–û–î–ê –ù–ï –ù–ê–®–ï –ú–ï–°–¢–û)";
                 
                 if (moveFwd || moveBwd || moveLft || moveRgt) {
                     const movingOutX = Math.abs(player.position.x) > BOUNDARY_DAMAGE_AREA && Math.sign(player.position.x) === Math.sign(moveVector.x);
                     const movingOutZ = Math.abs(player.position.z) > BOUNDARY_DAMAGE_AREA && Math.sign(player.position.z) === Math.sign(moveVector.z);
                     
                     if (movingOutX || movingOutZ) {
                         const damagePerSecond = Math.floor(Math.random() * 6) + 30; 
                         playerHP -= damagePerSecond * dt * 2; 
                         
                         if (playerHP <= 0) { endGame(); }
                         document.getElementById('hpDisplay').innerText = `‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: ${Math.max(0, Math.floor(playerHP))}`;
                     }
                 }
            } else {
                 boundaryWarning.style.display = 'none';
            }

            let nearCar = false; cars.forEach(c => { if(player.position.distanceTo(c.position) < 5) nearCar = true; });
            document.getElementById('carHint').style.display = nearCar ? 'block' : 'none';
            if ((moveFwd||moveBwd||moveLft||moveRgt) && player.userData.canJump) weaponGroup.position.y = -0.4 + Math.sin(performance.now()*0.015)*0.02;
        }

        function npcShoot(npc) { /* ... */ }
        function policeCarAttack(pCar, tCar) { /* ... */ }

        function updateMiniMap() {
            const mapDiv = document.getElementById('mapContent');
            const mapW = MINIMAP_SIZE_PX;
            const mapH = MINIMAP_SIZE_PX;
            
            const playerX = currentCar ? currentCar.position.x : player.position.x;
            const playerZ = currentCar ? currentCar.position.z : player.position.z;

            const offsetMapX = mapW / 2 - playerX * MINIMAP_SCALE;
            const offsetMapZ = mapH / 2 - (-playerZ * MINIMAP_SCALE); 

            mapDiv.style.transform = `translate(${offsetMapX}px, ${offsetMapZ}px)`;

            Array.from(mapDiv.children).forEach(el => {
                if (el.id !== 'playerMarker') el.remove();
            });

            // –†–ò–°–û–í–ê–ù–ò–ï –ó–î–ê–ù–ò–ô 
            mapBuildings.forEach(building => {
                const dist = Math.sqrt(Math.pow(building.x - playerX, 2) + Math.pow(building.z - playerZ, 2));
                if (dist > MAP_VIEW_RADIUS * 1.5) return;

                const mapRelX = building.x * MINIMAP_SCALE;
                const mapRelZ = -building.z * MINIMAP_SCALE;

                const bDiv = document.createElement('div');
                bDiv.className = 'mapBuilding';
                bDiv.style.width = `${building.w * MINIMAP_SCALE}px`;
                bDiv.style.height = `${building.d * MINIMAP_SCALE}px`;
                
                bDiv.style.left = `${mapRelX - (building.w * MINIMAP_SCALE / 2)}px`;
                bDiv.style.top = `${mapRelZ - (building.d * MINIMAP_SCALE / 2)}px`;

                mapDiv.appendChild(bDiv);
            });
            
            // –ú–ê–†–ö–ï–† –ò–ì–†–û–ö–ê
            const playerMarker = document.getElementById('playerMarker');
            playerMarker.style.left = `${playerX * MINIMAP_SCALE}px`;
            playerMarker.style.top = `${-playerZ * MINIMAP_SCALE}px`;
            
            // –ú–ê–†–ö–ï–†–´ –ü–û–õ–ò–¶–ò–ò
            npcs.filter(n => n.userData.isPolice && wantedLevel > 0).forEach(npc => {
                const npcX = npc.position.x;
                const npcZ = npc.position.z;
                
                if (Math.abs(npcX - playerX) < MAP_VIEW_RADIUS && Math.abs(npcZ - playerZ) < MAP_VIEW_RADIUS) {
                    
                    const mapRelX = npcX * MINIMAP_SCALE;
                    const mapRelZ = -npcZ * MINIMAP_SCALE;

                    const marker = document.createElement('div');
                    marker.className = 'mapMarker policeMarker';
                    
                    marker.style.left = `${mapRelX}px`;
                    marker.style.top = `${mapRelZ}px`;
                    mapDiv.appendChild(marker);
                }
            });
        }


        // === –û–°–ù–û–í–ù–û–ô –¶–ò–ö–õ –ê–ù–ò–ú–ê–¶–ò–ò (–ò—Å–ø—Ä–∞–≤–ª–µ–Ω –∏ –¥–æ–ø–æ–ª–Ω–µ–Ω) ===
        function animate() {
            requestAnimationFrame(animate);
            if (!isGameActive) return;
            const dt = (performance.now() - prevTime) / 1000; prevTime = performance.now();
            gameTime += dt * 0.05; if (gameTime>=24) gameTime=0; document.getElementById('timeDisplay').innerText = Math.floor(gameTime)+":00";

            if (currentCar) {
                // –õ–æ–≥–∏–∫–∞ –≤–æ–∂–¥–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞
                if (moveFwd) carSpeed += 40 * dt; 
                if (moveBwd) carSpeed -= 25 * dt; 
                carSpeed *= 0.99; 
                
                if (Math.abs(carSpeed) > 0.2) {
                    const turn = 2.5 * dt * (carSpeed > 0 ? 1 : -1);
                    if (moveLft) currentCar.rotation.y += turn;
                    if (moveRgt) currentCar.rotation.y -= turn;
                }
                
                const moveDist = carSpeed * dt;
                const forwardVector = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), currentCar.rotation.y);
                let collided = false;
                
                const carWidth = 2; const carLength = 4.6;
                const collisionRayOrigin = currentCar.position.clone(); collisionRayOrigin.y = 1; 
                const collisionCheckPoints = [
                    collisionRayOrigin.clone().add(forwardVector.clone().multiplyScalar(carLength / 2 * 0.9)),
                    collisionRayOrigin.clone().add(forwardVector.clone().multiplyScalar(carLength / 2 * 0.9)).add(new THREE.Vector3().set(forwardVector.z, 0, -forwardVector.x).normalize().multiplyScalar(carWidth/2)), 
                    collisionRayOrigin.clone().add(forwardVector.clone().multiplyScalar(carLength / 2 * 0.9)).add(new THREE.Vector3().set(forwardVector.z, 0, -forwardVector.x).normalize().multiplyScalar(-carWidth/2)) 
                ];
                const maxDistance = Math.abs(moveDist) + 5; 

                for(let point of collisionCheckPoints) {
                    carRaycaster.set(point, forwardVector);
                    const hits = carRaycaster.intersectObjects(collisionObjects, false);
                    if (hits.length > 0 && hits[0].distance < maxDistance) {
                        collided = true; carSpeed *= -0.7; 
                        const bounceDir = forwardVector.clone().negate().multiplyScalar(5 * dt); 
                        currentCar.position.add(bounceDir);
                        break;
                    }
                }
                if (!collided) { currentCar.translateZ(-moveDist); }
                currentCar.position.y = 0; 
                if (Math.abs(carSpeed) > 8) { npcs.forEach(npc => { if (npc.position.distanceTo(currentCar.position) < 3) killNPC(npc, true); }); }
                
                const offset = new THREE.Vector3(0, 5, 10); offset.applyMatrix4(currentCar.matrixWorld);
                camera.position.lerp(offset, 0.1); camera.lookAt(currentCar.position);

            } else {
                // –î–≤–∏–∂–µ–Ω–∏–µ –ø–µ—à–µ—Ö–æ–¥–∞
                movePlayer(dt);
            }

            // --- –û–ë–ù–û–í–õ–ï–ù–ò–ï –õ–û–ì–ò–ö–ò NPC –ò –¢–†–ê–§–ò–ö–ê (–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ) ---
            npcs.forEach(npc => updateNPC(npc, dt)); 
            cars.filter(c => c.userData.isTraffic || c.userData.isPolice).forEach(car => updateTraffic(car, dt));
            
            // --- 1. –õ–û–ì–ò–ö–ê –¢–ê–ô–ú–ï–†–ê –†–û–ó–´–°–ö–ê (–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ) ---
            const wantedTimerDisplay = document.getElementById('wantedLevelTimer');
            
            if (wantedLevel > 0) {
                // –£—Å–ª–æ–≤–∏–µ –¥–ª—è –Ω–∞—á–∞–ª–∞ —Å–ø–∞–¥–∞: –Ω–µ—Ç –ø–æ–ª–∏—Ü–∏–∏ –≤ —Ä–∞–¥–∏—É—Å–µ 150
                const isPoliceNear = npcs.some(npc => npc.userData.isPolice && player.position.distanceTo(npc.position) < 150);
                
                if (!isPoliceNear) {
                    wantedDecayTimer += dt;
                    wantedTimerDisplay.style.display = 'block';
                    
                    const remaining = Math.max(0, WANTED_DECAY_TIME - wantedDecayTimer);
                    wantedTimerDisplay.innerText = `–°–ù–Ø–¢–ò–ï: ${remaining.toFixed(1)} —Å`;
                    
                    if (wantedDecayTimer >= WANTED_DECAY_TIME) {
                        wantedLevel = Math.max(0, wantedLevel - 1);
                        wantedDecayTimer = 0;
                        updateWantedLevelDisplay();
                        
                        if (wantedLevel === 0) {
                            wantedTimerDisplay.style.display = 'none';
                        }
                    }
                } else {
                    wantedDecayTimer = 0; // –°–±—Ä–æ—Å —Ç–∞–π–º–µ—Ä–∞, –µ—Å–ª–∏ –ø–æ–ª–∏—Ü–∏—è —Ä—è–¥–æ–º
                    wantedTimerDisplay.style.display = 'none';
                }
            } else {
                wantedDecayTimer = 0;
                wantedTimerDisplay.style.display = 'none';
            }

            // --- –ö–û–ù–ï–¶ –ì–õ–ê–í–ù–û–ì–û –¶–ò–ö–õ–ê ---
            renderer.render(scene, camera);
        } // --- –ó–ê–ö–†–´–¢–ò–ï –§–£–ù–ö–¶–ò–ò ANIMATE ---


        // --- –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ö–ù–û–ü–û–ö –ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø ---

        const onKeyDown = (event) => {
            if (!isGameActive) return;
            switch(event.code) {
                case 'KeyW': moveFwd=true; break; case 'KeyS': moveBwd=true; break;
                case 'KeyA': moveLft=true; break; case 'KeyD': moveRgt=true; break;
                case 'Space': 
                    if (!currentCar && player.userData.canJump) {
                        player.userData.velocityY = 15; // –°–∏–ª–∞ –ø—Ä—ã–∂–∫–∞
                        player.userData.canJump = false;
                    }
                    break;
                case 'KeyF': enterExitCar(); break;
                case 'Digit1': currentWeapon='FIST'; document.getElementById('weaponDisplay').innerText = 'üëä –ö–£–õ–ê–ö–ò'; break;
                case 'Digit2': currentWeapon='PISTOL'; document.getElementById('weaponDisplay').innerText = 'üî´ –ü–ò–°–¢–û–õ–ï–¢'; break;
            }
        };

        const onKeyUp = (event) => {
            if (!isGameActive) return;
            switch(event.code) {
                case 'KeyW': moveFwd=false; break; case 'KeyS': moveBwd=false; break;
                case 'KeyA': moveLft=false; break; case 'KeyD': moveRgt=false; break;
            }
        };

        const onMouseMove = (event) => {
            if (!document.pointerLockElement) return;
            player.rotation.y -= event.movementX / 500;
            camera.rotation.x -= event.movementY / 500;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        };

        const onMouseDown = (event) => {
            if (!isGameActive || !document.pointerLockElement) return;
            if (event.button === 0) {
                if (!currentCar) attack(event.button);
            }
        };

        function attack(button) {
            if (currentWeapon === 'FIST') {
                playSound('punch');
                // –õ–æ–≥–∏–∫–∞ —Ä—É–∫–æ–ø–∞—à–Ω–æ–≥–æ –±–æ—è
            } else if (currentWeapon === 'PISTOL') {
                playSound('shoot');
                // –õ–æ–≥–∏–∫–∞ —Å—Ç—Ä–µ–ª—å–±—ã
            }
        }
        
        function enterExitCar() {
            if (currentCar) {
                // –í—ã—Ö–æ–¥
                currentCar.remove(camera);
                currentCar.remove(weaponGroup);
                player.position.copy(currentCar.position).add(new THREE.Vector3(2, CAMERA_HEIGHT, 0).applyAxisAngle(new THREE.Vector3(0,1,0), currentCar.rotation.y));
                player.rotation.y = currentCar.rotation.y;
                player.add(camera);
                player.add(weaponGroup);
                currentCar.userData.isDriver = false;
                currentCar = null;
                carSpeed = 0;
                document.body.requestPointerLock();
                document.getElementById('crosshair').style.display = 'block';
            } else {
                // –ü–æ–∏—Å–∫ –∏ –≤—Ö–æ–¥
                const targetCar = cars.find(c => player.position.distanceTo(c.position) < 5);
                if (targetCar) {
                    currentCar = targetCar;
                    player.remove(camera);
                    player.remove(weaponGroup);
                    currentCar.add(camera);
                    currentCar.add(weaponGroup);
                    camera.position.set(0, 1.5, 0); 
                    camera.lookAt(0, 0, -1);
                    currentCar.userData.isDriver = true;
                    document.exitPointerLock();
                    document.getElementById('crosshair').style.display = 'none';
                    if (currentCar.userData.isPolice) { wantedLevel = Math.max(1, wantedLevel); updateWantedLevelDisplay(); }
                }
            }
        }

        // --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò–ì–†–´ ---
        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('menu').style.display = 'none'; 
            init(); 
            isGameActive = true; 
            document.body.requestPointerLock(); 
            document.getElementById('hpDisplay').innerText = `‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: ${playerHP}`;
            updateWantedLevelDisplay();
        });

        document.getElementById('help-btn').addEventListener('click', () => {
             document.getElementById('infoBox').style.display = 'block';
        });

    </script>
</body>
</html>