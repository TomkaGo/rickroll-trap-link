<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTA –õ–Å–•–ê (V12.4 - –ê–ö–¢–ò–í–ù–´–ô –ü–ê–¢–†–£–õ–¨)</title>
    <style>
        /* --- –°–¢–ò–õ–ò (–ë–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) --- */
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; user-select: none; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }

        /* CROSSHAIR */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><circle cx="10" cy="10" r="2" fill="white" stroke="black"/><path d="M10,0 L10,6 M10,14 L10,20 M0,10 L6,10 M14,10 L20,10" stroke="black" stroke-width="1"/></svg>') no-repeat center;
            transform: translate(-50%, -50%); z-index: 10; pointer-events: none;
        }

        /* HUD */
        #hud {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            text-align: right; color: white; text-shadow: 2px 2px 2px #000; font-weight: bold;
        }
        
        #carHint {
            position: absolute; bottom: 20%; width: 100%; text-align: center;
            color: #ffff00; font-size: 2em; text-shadow: 2px 2px 4px black; display: none;
            animation: bounce 1s infinite;
        }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }

        /* BOUNDARY WARNING (–ù–û–í–´–ô –¢–ï–ö–°–¢) */
        #boundaryWarning {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; justify-content: center; align-items: center;
            background: rgba(255, 0, 0, 0.4); /* –ß—É—Ç—å –±–æ–ª–µ–µ –∑–∞–º–µ—Ç–Ω—ã–π —Ñ–æ–Ω */
            color: white; font-size: 4em; font-weight: bold;
            text-shadow: 0 0 10px black;
            z-index: 50; 
            pointer-events: none;
            text-align: center;
            padding: 20px;
        }

        /* --- –ú–ò–ù–ò-–ö–ê–†–¢–ê --- */
        #miniMap {
            position: absolute; bottom: 20px; left: 20px; z-index: 10;
            width: 200px; height: 200px; 
            background: #888888; 
            border: 3px solid white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        #mapContent {
            position: absolute;
            width: 200px;
            height: 200px;
            transform-origin: 50% 50%; 
        }

        /* –ú–∞—Ä–∫–µ—Ä—ã –∏ —ç–ª–µ–º–µ–Ω—Ç—ã 2D –∫–∞—Ä—Ç—ã */
        .mapMarker {
            position: absolute;
            width: 8px; height: 8px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        #playerMarker { background-color: lime; border: 1px solid black; z-index: 5; }
        .policeMarker { background-color: red; border: 1px solid black; z-index: 4; }
        .mapBuilding {
            position: absolute;
            background-color: #228b22; 
            border: 1px solid #000;
            box-sizing: border-box;
            opacity: 0.8;
        }

        /* --- –ù–û–í–û–ï –ú–ï–ù–Æ: –ö–†–ê–°–ò–í–û–ï –ò –°–û–ß–ù–û–ï --- */
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0f0f0f 0%, #3a0000 100%); /* –§–æ–Ω —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º */
            background-size: 200% 200%; /* –î–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ */
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: white;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
            animation: backgroundShift 15s infinite alternate; /* –ê–Ω–∏–º–∞—Ü–∏—è —Ñ–æ–Ω–∞ */
        }
        @keyframes backgroundShift {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }

        #menu h1 { 
            font-size: 7em; color: #ff0000; margin: 0; 
            text-shadow: 6px 6px 0px #000, 8px 8px 15px rgba(255, 0, 0, 0.7); /* –°–æ—á–Ω—ã–π —Ç–µ–Ω—å */
            font-family: 'Impact', sans-serif;
            letter-spacing: 10px;
            animation: titlePulse 2s infinite alternate; /* –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–≥–æ–ª–æ–≤–∫–∞ */
        }
        @keyframes titlePulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }
        
        #menu #subtitle {
            font-size: 2em; color: #ffaa00; text-shadow: 2px 2px 0px black;
            margin-top: 10px;
        }

        #menu button {
            background: #ffaa00;
            color: black;
            border: 5px solid #ff0000; /* –ñ–∏—Ä–Ω–∞—è –∫—Ä–∞—Å–Ω–∞—è —Ä–∞–º–∫–∞ */
            padding: 20px 40px;
            font-size: 1.8em;
            cursor: pointer;
            margin: 15px;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            transform: skew(-5deg); /* –ù–∞–∫–ª–æ–Ω –∫–Ω–æ–ø–∫–∏ */
        }
        #menu button:hover {
            background: #ffcc00;
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.9);
            transform: skew(-5deg) scale(1.05); /* –õ–µ–≥–∫–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ */
            border-color: #ffffff;
        }
        
        /* BUSTED SCREEN */
        #bustedScreen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: red;
            flex-direction: column; justify-content: center; align-items: center; z-index: 100;
        }

        /* HELP BOX */
        #infoBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 5px solid red;
            padding: 40px;
            color: white;
            font-size: 1.2em;
            text-align: left;
            z-index: 101;
            display: none;
            box-shadow: 0 0 30px red;
            max-width: 600px;
        }
        #infoBox button {
            margin-top: 20px;
            background: red;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 1em;
            display: block;
            width: 100%;
        }
        #infoBox h3 {
            text-align: center;
            color: #ffaa00;
            border-bottom: 2px solid red;
            padding-bottom: 10px;
        }
        #infoBox p, #infoBox ul {
             margin-bottom: 15px;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="carHint">–ù–ê–ñ–ú–ò–¢–ï [F], –ß–¢–û–ë–´ –°–ï–°–¢–¨ –í –ú–ê–®–ò–ù–£</div>
    <div id="boundaryWarning"></div>
    
    <div id="hud">
        <div id="timeDisplay">12:00</div>
        <div id="hpDisplay" style="color: red; margin-top: 5px;">‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: 100</div>
        <div id="weaponDisplay" style="color: orange; margin-top: 5px;">üëä –ö–£–õ–ê–ö–ò</div>
        <div id="wantedLevel" style="color: white; margin-top: 5px;">‚òÖ –†–û–ó–´–°–ö: 0</div>
        <div style="font-size: 0.8em; color: #ffff00; margin-top:10px;">V12.4 (–ê–ö–¢–ò–í–ù–´–ô –ü–ê–¢–†–£–õ–¨)</div>
    </div>
    
    <div id="miniMap">
        <div id="mapContent">
             <div id="playerMarker" class="mapMarker" style="left: 50%; top: 50%;"></div>
        </div>
    </div>

    <div id="menu">
        <div>
            <span class="bomb-emoji" style="font-size: 3em; margin-right: 20px;">üö®</span>
            <h1>GTA –õ–Å–•–ê</h1>
            <span class="bomb-emoji" style="font-size: 3em; margin-left: 20px;">üöì</span>
        </div>
        <div id="subtitle" style="font-size: 1.5em; color: #ffaa00; text-shadow: 2px 2px 0px black;">–°–ê–ú–´–ô –ö–†–ò–ú–ò–ù–ê–õ–¨–ù–´–ô –°–ò–ú–£–õ–Ø–¢–û–†</div>
        <p style="margin-top: 50px; font-size: 1.8em; color: yellow; text-shadow: 2px 2px black;">–°–û–ó–î–ê–ù–û –¢–ò–ú–£–†–û–ú</p>
        <div class="menu-options">
            <button id="startBtn">–ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button>
            <button id="help-btn">–ü–û–ú–û–©–¨</button>
        </div>
    </div>

    <div id="infoBox">
        <h3>–ü–û–ú–û–©–¨: GTA –õ–Å–•–ê</h3>

        <h4>üìñ –°—é–∂–µ—Ç –∏ –°–º—ã—Å–ª</h4>
        <p>–¢—ã, –õ—ë—Ö–∞, ‚Äî –∫—Ä—É—Ç–æ–π —á—É–≤–∞–∫ –≤ –±–æ–ª—å—à–æ–º –≥–æ—Ä–æ–¥–µ, –∫–æ—Ç–æ—Ä—ã–π –≤—Å–µ–≥–¥–∞ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ –∫–∞–∫–∏–µ-—Ç–æ –ø–µ—Ä–µ–¥—Ä—è–≥–∏. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî **–≤—ã–∂–∏—Ç—å, –ø–æ–¥–Ω—è—Ç—å —É—Ä–æ–≤–µ–Ω—å —Ä–æ–∑—ã—Å–∫–∞ –∏ –∏–∑–±–µ–≥–∞—Ç—å –º–µ–Ω—Ç–æ–≤!**</p>
        <p>–°–º—ã—Å–ª –∏–≥—Ä—ã: **–£—Å—Ç—Ä–∞–∏–≤–∞–π —Ö–∞–æ—Å, —É–≥–æ–Ω—è–π —Ç–∞—á–∫–∏ –∏ –±–µ–≥–∏ –æ—Ç –ø—Ä–µ—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è!**</p>

        <h4>üéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h4>
        <ul>
            <li>**WASD:** –î–≤–∏–∂–µ–Ω–∏–µ (—Ö–æ–¥—å–±–∞/–µ–∑–¥–∞)</li>
            <li>**–ú—ã—à—å:** –û–±–∑–æ—Ä/–ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã</li>
            <li>**–õ–ö–ú (–õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏):** –£–¥–∞—Ä / –í—ã—Å—Ç—Ä–µ–ª</li>
            <li>**F:** –°–µ—Å—Ç—å –≤ –º–∞—à–∏–Ω—É / –í—ã–π—Ç–∏ –∏–∑ –º–∞—à–∏–Ω—ã</li>
            <li>**1:** –í—ã–±—Ä–∞—Ç—å **–ö—É–ª–∞–∫–∏** üëä</li>
            <li>**2:** –í—ã–±—Ä–∞—Ç—å **–ü–∏—Å—Ç–æ–ª–µ—Ç** üî´</li>
        </ul>

        <h4>üö® –†–æ–∑—ã—Å–∫ –∏ –ü–æ–ª–∏—Ü–∏—è</h4>
        <p>–ö–∞–∂–¥–æ–µ —É–±–∏–π—Å—Ç–≤–æ (–ø–µ—à–µ—Ö–æ–¥–∞ –∏–ª–∏ –ø–æ–ª–∏—Ü–µ–π—Å–∫–æ–≥–æ) –ø–æ–≤—ã—à–∞–µ—Ç —É—Ä–æ–≤–µ–Ω—å —Ä–æ–∑—ã—Å–∫–∞ (‚òÖ). –ü–æ–ª–∏—Ü–∏—è —Ç–µ–ø–µ—Ä—å —Å—Ç—Ä–µ–ª—è–µ—Ç –∏–∑–¥–∞–ª–µ–∫–∞, –∞ –≤ –º–∞—à–∏–Ω–µ –±—É–¥–µ—Ç –≤–∞—Å **–ø—Ä–µ—Å–ª–µ–¥–æ–≤–∞—Ç—å –∏ –æ–±—Å—Ç—Ä–µ–ª–∏–≤–∞—Ç—å**! –ü–æ–ª–∏—Ü–µ–π—Å–∫–∏—Ö —Å—Ç–∞–ª–æ –±–æ–ª—å—à–µ ‚Äî –±—É–¥—å –æ—Å—Ç–æ—Ä–æ–∂–µ–Ω!</p>

        <button onclick="document.getElementById('infoBox').style.display='none'">–ó–ê–ö–†–´–¢–¨</button>
    </div>

    <div id="bustedScreen">
        <h1 style="font-family: Impact; letter-spacing: 5px; color: red;">–ü–û–ô–ú–ê–ù</h1>
        <h2 style="font-size: 1.5em; color: #fff;">–®–û –¢–£–¢ –î–£–ú–ê–õ –í –°–ö–ê–ó–ö–£ –ü–û–ü–ê–õ</h2>
        <button onclick="location.reload()" style="background: red; border-color: #ff3333;">–ü–û–í–¢–û–†–ò–¢–¨</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // === –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø GTA LITE 3D (V12.4) ===
        const CAMERA_HEIGHT = 1.5;
        const NPC_COUNT = 200;       // –£–≤–µ–ª–∏—á–µ–Ω–æ –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ NPC
        const POLICE_COUNT = 20;     // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª–∏—Ü–µ–π—Å–∫–∏—Ö
        const TRAFFIC_CAR_COUNT = 15; 
        const RESPAWN_INTERVAL = 90 * 1000; 
        const MAP_SIZE = 400; 
        const BORDER_COLLISION_SIZE = 5; 
        const VISIBLE_WALL_HEIGHT = 1; 
        const PLAYER_COLLISION_RADIUS = 1.5; 
        const MINIMAP_SIZE_PX = 200; 
        const MINIMAP_SCALE = 0.8; 
        const MAP_VIEW_RADIUS = MINIMAP_SIZE_PX / MINIMAP_SCALE / 2; 
        
        // === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
        let scene, camera, renderer;
        let player, weaponGroup;
        let raycaster;
        
        const collisionObjects = [];
        const npcs = [];
        const cars = [];
        const particles = [];
        const mapBuildings = []; 
        
        let isGameActive = false;
        let currentCar = null;
        let moveFwd=false, moveBwd=false, moveLft=false, moveRgt=false;
        let prevTime = performance.now();
        
        let wantedLevel = 0;
        let playerHP = 100; 
        let currentWeapon = 'FIST';
        let gameTime = 10;
        let carSpeed = 0;
        
        const carRaycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(), 0, 10);
        
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let policeCar = null;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 300);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            player = new THREE.Group();
            player.add(camera);
            player.position.set(0, CAMERA_HEIGHT, 0); 
            scene.add(player);

            createWeapons();
            
            const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambLight);
            const sunLight = new THREE.DirectionalLight(0xffeebb, 0.9);
            sunLight.position.set(50, 150, 100);
            sunLight.castShadow = true;
            scene.add(sunLight);

            createCity();
            createStreetFurniture();
            
            createMapBounds(); 
            
            createEasterEggPullUp(150, 150, Math.PI); 
            createEasterEggPullUp(-150, -150, 0); 
            
            spawnParkingLotCars(); 
            
            spawnTraffic();
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è NPC –∏ –ü–æ–ª–∏—Ü–∏–∏
            spawnNPCs(POLICE_COUNT, true);
            spawnNPCs(NPC_COUNT - POLICE_COUNT, false);
            
            setInterval(respawnNPCs, RESPAWN_INTERVAL); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        // === –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –°–ü–ï–¶–ò–ê–õ–¨–ù–ê–Ø –ü–ê–†–ö–û–í–ö–ê –£ –°–ü–ê–í–ù–ê ===
        function spawnParkingLotCars() {
            const spawnCars = [
                { color: 0xff0000, isPolice: false, x: -10, z: 0 },
                { color: 0x00FF00, isPolice: false, x: -15, z: 0 },
                { color: 0, isPolice: true, x: -20, z: 0 }
            ];

            spawnCars.forEach(sc => {
                const car = createCarMesh(sc.color, sc.isPolice);
                car.position.set(sc.x, 0, sc.z);
                car.rotation.y = Math.PI / 2;
                car.castShadow = true;
                cars.push(car);
                scene.add(car);
                collisionObjects.push(car.children[0]);
            });
        }


        // === –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –°–û–ó–î–ê–ù–ò–Ø –ü–ê–°–•–ê–õ–ö–ò ===
        function createEasterEggPullUp(x, z, rotY) {
            const group = new THREE.Group();
            const bodyColor = (x > 0) ? 0xcc0000 : 0x0000cc; 
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.5, 0.3), new THREE.MeshStandardMaterial({color: bodyColor})); 
            body.position.y = 0.75;
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.25), new THREE.MeshStandardMaterial({color: 0xffe0bd})); 
            head.position.y = 1.6;
            
            const armGeo = new THREE.BoxGeometry(0.8, 0.15, 0.15); 
            const armMat = new THREE.MeshStandardMaterial({color: 0xffe0bd});
            
            const arms = new THREE.Mesh(armGeo, armMat);
            arms.position.set(0, 1.85, -0.2); 
            group.add(arms);

            group.add(body, head);
            
            group.position.set(x, 0, z); 
            group.rotation.y = rotY; 
            group.castShadow = true;
            group.name = "EasterEggNPC"; 

            scene.add(group);
        }

        // === –°–û–ó–î–ê–ù–ò–ï –°–ö–ê–ú–ï–ô–ö–ò ===
        function createBench(x, y, z, rotY) {
            const plank = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 0.8), new THREE.MeshStandardMaterial({color: 0x8b4513})); 
            plank.position.y = 0.8;
            
            const legGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2); 
            const legMat = new THREE.MeshStandardMaterial({color: 0x5c4033});

            const l1 = new THREE.Mesh(legGeo, legMat); l1.position.set( 1.3, 0.4,  0.3);
            const l2 = new THREE.Mesh(legGeo, legMat); l2.position.set(-1.3, 0.4,  0.3);
            const l3 = new THREE.Mesh(legGeo, legMat); l3.position.set( 1.3, 0.4, -0.3); 
            const l4 = new THREE.Mesh(legGeo, legMat); l4.position.set(-1.3, 0.4, -0.3); 
            
            const benchGroup = new THREE.Group(); 
            benchGroup.add(plank, l1, l2, l3, l4); 
            
            benchGroup.position.set(x, y, z); 
            benchGroup.rotation.y = rotY; 
            benchGroup.castShadow = true; 
            scene.add(benchGroup);
            
            collisionObjects.push(plank); 
            collisionObjects.push(l1); 
            collisionObjects.push(l2);
            collisionObjects.push(l3); 
            collisionObjects.push(l4);
        }
        
        // --- –î–í–ò–ñ–ï–ù–ò–ï –ü–ï–®–ï–•–û–î–ê (–û–ë–ù–û–í–õ–ï–ù –¢–ï–ö–°–¢) ---
        function movePlayer(dt) {
            const speed = 8; const dir = new THREE.Vector3();
            if (moveFwd) dir.z -= 1; if (moveBwd) dir.z += 1; if (moveLft) dir.x -= 1; if (moveRgt) dir.x += 1;
            dir.normalize().multiplyScalar(speed * dt);
            
            const moveVector = dir.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
            const newPos = player.position.clone().add(moveVector);
            newPos.y = 0;

            for(let obj of collisionObjects) {
                const oPos = new THREE.Vector3();
                obj.updateWorldMatrix(true, false);
                oPos.setFromMatrixPosition(obj.matrixWorld); 
                oPos.y = 0;

                if (newPos.distanceTo(oPos) < PLAYER_COLLISION_RADIUS) { 
                    const push = newPos.clone().sub(oPos).normalize().multiplyScalar(1.0); 
                    player.position.x += push.x; 
                    player.position.z += push.z;
                    dir.set(0, 0, 0); 
                    break;
                }
            }
            
            player.translateX(dir.x); player.translateZ(dir.z); 
            player.position.y = CAMERA_HEIGHT;

            // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –Ω–µ–≤–∏–¥–∏–º–æ–π –≥—Ä–∞–Ω–∏—Ü–µ (–ù–û–í–´–ô –¢–ï–ö–°–¢)
            const boundaryWarning = document.getElementById('boundaryWarning');
            const BOUNDARY_RANGE = 50; 
            
            if (Math.abs(player.position.x) > MAP_SIZE - BOUNDARY_RANGE || Math.abs(player.position.z) > MAP_SIZE - BOUNDARY_RANGE) {
                 boundaryWarning.style.display = 'flex';
                 boundaryWarning.innerText = "üõë –õ–Å–•–ê –î–£–†–ê–ß–û–ö –ù–ï –õ–ï–ó–¨ –¢–£–î–ê (–°–í–û–ë–û–î–ê –ù–ï –ù–ê–®–ï –ú–ï–°–¢–û)";
            } else {
                 boundaryWarning.style.display = 'none';
            }

            let nearCar = false; cars.forEach(c => { if(player.position.distanceTo(c.position) < 5) nearCar = true; });
            document.getElementById('carHint').style.display = nearCar ? 'block' : 'none';
            if (moveFwd||moveBwd||moveLft||moveRgt) weaponGroup.position.y = -0.4 + Math.sin(performance.now()*0.015)*0.02;
        }

        // === –ì–õ–û–ë–ê–õ–¨–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –í–´–°–¢–†–ï–õ–ê NPC ===
        function npcShoot(npc) {
            if (npc.userData.lastShot && performance.now() - npc.userData.lastShot < 1000) return; 
            if (currentCar) return; 

            playSound('shoot'); 
            npc.userData.lastShot = performance.now();
            
            const targetPos = player.position; 
            const direction = new THREE.Vector3().subVectors(targetPos, npc.position).normalize();
            
            raycaster.set(new THREE.Vector3(npc.position.x, 1.5, npc.position.z), direction);
            
            const intersectables = collisionObjects.concat(npcs).concat([player]);
            const hits = raycaster.intersectObjects(intersectables);
            
            if (hits.length > 0) {
                const hitPlayer = hits.find(hit => {
                    let obj = hit.object;
                    while (obj.parent) {
                        if (obj === player) return true;
                        obj = obj.parent;
                    }
                    return false;
                });

                if (hitPlayer && hitPlayer.distance < 150) { 
                    const damage = Math.floor(Math.random() * 3) + 3; // –£—Ä–æ–Ω 3-5 HP
                    playerHP -= damage;
                    document.getElementById('hpDisplay').innerText = `‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: ${playerHP}`;
                    
                    if (playerHP <= 0) {
                        endGame(); 
                    }
                }
            }
        }
        
        // === –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ê–¢–ê–ö–ê –ü–û–õ–ò–¶–ï–ô–°–ö–û–ô –ú–ê–®–ò–ù–´ ===
        function policeCarAttack(pCar, tCar) {
            const distance = pCar.position.distanceTo(tCar.position);
            const attackRange = 75; 
            const attackCooldown = 1500; 

            if (distance < attackRange && pCar.userData.lastShotTime + attackCooldown < performance.now()) {
                pCar.userData.lastShotTime = performance.now();
                playSound('shoot'); 

                if (Math.random() < 0.7) { 
                    const damage = Math.floor(Math.random() * 3) + 3; 
                    playerHP -= damage;
                    
                    document.getElementById('hpDisplay').innerText = `‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: ${playerHP}`;
                    
                    if (playerHP <= 0) {
                        endGame();
                    }
                }
            }
        }


        // === –ú–ò–ù–ò-–ö–ê–†–¢–ê ===
        function updateMiniMap() {
            const mapDiv = document.getElementById('mapContent');
            const mapW = MINIMAP_SIZE_PX;
            const mapH = MINIMAP_SIZE_PX;
            
            const playerX = currentCar ? currentCar.position.x : player.position.x;
            const playerZ = currentCar ? currentCar.position.z : player.position.z;

            const offsetMapX = mapW / 2 - playerX * MINIMAP_SCALE;
            const offsetMapZ = mapH / 2 - (-playerZ * MINIMAP_SCALE); 

            mapDiv.style.transform = `translate(${offsetMapX}px, ${offsetMapZ}px)`;

            Array.from(mapDiv.children).forEach(el => {
                if (el.id !== 'playerMarker') el.remove();
            });

            // –†–ò–°–û–í–ê–ù–ò–ï –ó–î–ê–ù–ò–ô 
            mapBuildings.forEach(building => {
                const dist = Math.sqrt(Math.pow(building.x - playerX, 2) + Math.pow(building.z - playerZ, 2));
                if (dist > MAP_VIEW_RADIUS * 1.5) return;

                const mapRelX = building.x * MINIMAP_SCALE;
                const mapRelZ = -building.z * MINIMAP_SCALE;

                const bDiv = document.createElement('div');
                bDiv.className = 'mapBuilding';
                bDiv.style.width = `${building.w * MINIMAP_SCALE}px`;
                bDiv.style.height = `${building.d * MINIMAP_SCALE}px`;
                
                bDiv.style.left = `${mapRelX - (building.w * MINIMAP_SCALE / 2)}px`;
                bDiv.style.top = `${mapRelZ - (building.d * MINIMAP_SCALE / 2)}px`;

                mapDiv.appendChild(bDiv);
            });
            
            // –ú–ê–†–ö–ï–† –ò–ì–†–û–ö–ê
            const playerMarker = document.getElementById('playerMarker');
            playerMarker.style.left = `${playerX * MINIMAP_SCALE}px`;
            playerMarker.style.top = `${-playerZ * MINIMAP_SCALE}px`;
            
            // –ú–ê–†–ö–ï–†–´ –ü–û–õ–ò–¶–ò–ò
            npcs.filter(n => n.userData.isPolice && wantedLevel > 0).forEach(npc => {
                const npcX = npc.position.x;
                const npcZ = npc.position.z;
                
                if (Math.abs(npcX - playerX) < MAP_VIEW_RADIUS && Math.abs(npcZ - playerZ) < MAP_VIEW_RADIUS) {
                    
                    const mapRelX = npcX * MINIMAP_SCALE;
                    const mapRelZ = -npcZ * MINIMAP_SCALE;

                    const marker = document.createElement('div');
                    marker.className = 'mapMarker policeMarker';
                    
                    marker.style.left = `${mapRelX}px`;
                    marker.style.top = `${mapRelZ}px`;
                    mapDiv.appendChild(marker);
                }
            });
        }


        // === –û–°–ù–û–í–ù–û–ô –¶–ò–ö–õ –ê–ù–ò–ú–ê–¶–ò–ò ===
        function animate() {
            requestAnimationFrame(animate);
            if (!isGameActive) return;
            const dt = (performance.now() - prevTime) / 1000; prevTime = performance.now();
            gameTime += dt * 0.05; if (gameTime>=24) gameTime=0; document.getElementById('timeDisplay').innerText = Math.floor(gameTime)+":00";

            if (currentCar) {
                // –õ–æ–≥–∏–∫–∞ –≤–æ–∂–¥–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞
                if (moveFwd) carSpeed += 40 * dt; 
                if (moveBwd) carSpeed -= 25 * dt; 
                carSpeed *= 0.99; 
                
                if (Math.abs(carSpeed) > 0.2) {
                    const turn = 2.5 * dt * (carSpeed > 0 ? 1 : -1);
                    if (moveLft) currentCar.rotation.y += turn;
                    if (moveRgt) currentCar.rotation.y -= turn;
                }
                
                const moveDist = carSpeed * dt;
                const forwardVector = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), currentCar.rotation.y);
                let collided = false;
                
                const carWidth = 2; const carLength = 4.6;
                const collisionRayOrigin = currentCar.position.clone(); collisionRayOrigin.y = 1; 
                const collisionCheckPoints = [
                    collisionRayOrigin.clone().add(forwardVector.clone().multiplyScalar(carLength / 2 * 0.9)),
                    collisionRayOrigin.clone().add(forwardVector.clone().multiplyScalar(carLength / 2 * 0.9)).add(new THREE.Vector3().set(forwardVector.z, 0, -forwardVector.x).normalize().multiplyScalar(carWidth/2)), 
                    collisionRayOrigin.clone().add(forwardVector.clone().multiplyScalar(carLength / 2 * 0.9)).add(new THREE.Vector3().set(forwardVector.z, 0, -forwardVector.x).normalize().multiplyScalar(-carWidth/2)) 
                ];
                const maxDistance = Math.abs(moveDist) + 5; 

                for(let point of collisionCheckPoints) {
                    carRaycaster.set(point, forwardVector);
                    const hits = carRaycaster.intersectObjects(collisionObjects, false);
                    if (hits.length > 0 && hits[0].distance < maxDistance) {
                        collided = true; carSpeed *= -0.7; 
                        const bounceDir = forwardVector.clone().negate().multiplyScalar(5 * dt); 
                        currentCar.position.add(bounceDir);
                        break;
                    }
                }
                if (!collided) { currentCar.translateZ(-moveDist); }
                currentCar.position.y = 0; 
                if (Math.abs(carSpeed) > 8) { npcs.forEach(npc => { if (npc.position.distanceTo(currentCar.position) < 3) killNPC(npc, true); }); }
                
                const offset = new THREE.Vector3(0, 5, 10); offset.applyMatrix4(currentCar.matrixWorld);
                camera.position.lerp(offset, 0.1); camera.lookAt(currentCar.position);

            } else {
                // –î–≤–∏–∂–µ–Ω–∏–µ –ø–µ—à–µ—Ö–æ–¥–∞
                movePlayer(dt);
            }

            // --- –õ–û–ì–ò–ö–ê –ü–û–õ–ò–¶–ï–ô–°–ö–û–ô –ú–ê–®–ò–ù–´ ---
            if (wantedLevel > 0 && currentCar && !policeCar) {
                const availableCars = cars.filter(c => c.userData.isPoliceCar && c !== currentCar && !c.userData.isBeingUsedByPolice);
                if (availableCars.length > 0) {
                    policeCar = availableCars[0]; 
                    policeCar.userData.isBeingUsedByPolice = true;
                    policeCar.userData.speed = 0; 
                    policeCar.userData.lastShotTime = performance.now();
                }
            }
            if (policeCar && currentCar) {
                const target = currentCar.position;
                const pCar = policeCar;
                const toTarget = new THREE.Vector3().subVectors(target, pCar.position);
                toTarget.y = 0;
                
                const distance = toTarget.length();
                if (distance < 5) { pCar.userData.speed *= 0.95; endGame(); }

                const angleToTarget = Math.atan2(toTarget.x, toTarget.z);
                const currentAngle = pCar.rotation.y;
                let angleDiff = angleToTarget - currentAngle;

                if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                const steering = Math.sign(angleDiff) * Math.min(Math.abs(angleDiff) * 0.5, 0.05);
                pCar.rotation.y += steering;

                pCar.userData.speed = Math.min(pCar.userData.speed + 15 * dt, 40);
                pCar.translateZ(-pCar.userData.speed * dt); 
                
                policeCarAttack(policeCar, currentCar);
            }
            
            // --- –õ–û–ì–ò–ö–ê NPC: –î–í–ò–ñ–ï–ù–ò–ï, –ü–ê–ù–ò–ö–ê –ò –°–¢–†–ï–õ–¨–ë–ê (–£–ª—É—á—à–µ–Ω –æ–±—Ö–æ–¥ –≥—Ä–∞–Ω–∏—Ü) ---
            const targetPos = currentCar ? currentCar.position : player.position;
            
            npcs.forEach(npc => {
                npc.position.y = 0; 
                let speed = 1.5;
                let targetDir = npc.userData.dir.clone();
                let shouldTurn = false;
                const NPC_BOUNDARY_FUDGE = 20; // –î–∏—Å—Ç–∞–Ω—Ü–∏—è –¥–ª—è —Ä–∞–Ω–Ω–µ–≥–æ –ø–æ–≤–æ—Ä–æ—Ç–∞ –æ—Ç –∫—Ä–∞—è

                // 1. –ü–∞–Ω–∏–∫–∞
                if (npc.userData.state === 'PANIC') { 
                    speed = 9; 
                    const danger = currentCar ? currentCar.position : player.position; 
                    const runAwayDir = new THREE.Vector3().subVectors(npc.position, danger); 
                    runAwayDir.y = 0;
                    runAwayDir.x += (Math.random() - 0.5) * 0.1; 
                    runAwayDir.z += (Math.random() - 0.5) * 0.1;
                    runAwayDir.normalize();
                    targetDir.lerp(runAwayDir, 0.15); 
                } 
                // 2. –ü–æ–ª–∏—Ü–∏—è
                else if (npc.userData.isPolice && wantedLevel > 0) { 
                    const distance = npc.position.distanceTo(targetPos);

                    if (currentCar) {
                        speed = 0; 
                        npc.lookAt(targetPos);
                    } else {
                        speed = 8; 
                        const toPlayer = new THREE.Vector3().subVectors(targetPos, npc.position).normalize(); 
                        targetDir.lerp(toPlayer, 0.05); 
                        npc.lookAt(targetPos);

                        if (distance < 2) endGame(); 
                        if (distance < 150 && npc.userData.hasWeapon === 'PISTOL') { 
                             npcShoot(npc);
                        }
                    }
                }

                const collisionDist = npc.userData.state === 'PANIC' ? 6 : 4; 
                
                // --- –ü–†–û–í–ï–†–ö–ê –ü–†–ï–î–£–ü–†–ï–ñ–î–ï–ù–ò–Ø –ì–†–ê–ù–ò–¶–´ ---
                const checkPosAhead = npc.position.clone().add(targetDir.clone().normalize().multiplyScalar(15));
                if (Math.abs(checkPosAhead.x) > MAP_SIZE - NPC_BOUNDARY_FUDGE || Math.abs(checkPosAhead.z) > MAP_SIZE - NPC_BOUNDARY_FUDGE) {
                    shouldTurn = true;
                }
                
                // --- –ü–†–û–í–ï–†–ö–ê –°–¢–ï–ù –ò –ó–î–ê–ù–ò–ô ---
                raycaster.set(new THREE.Vector3(npc.position.x, 1, npc.position.z), targetDir);
                const hits = raycaster.intersectObjects(collisionObjects);
                
                if (hits.length > 0 && hits[0].distance < collisionDist) { 
                    shouldTurn = true; 
                } 
                
                if (shouldTurn) {
                    // –ü–æ–≤–æ—Ä–æ—Ç, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è –∏–ª–∏ –≥—Ä–∞–Ω–∏—Ü—ã
                    const rotationAngle = Math.PI/3 + Math.random() * Math.PI/3; 
                    targetDir.applyAxisAngle(new THREE.Vector3(0,1,0), rotationAngle); 
                }
                
                npc.userData.dir.copy(targetDir.normalize()); 

                const nextPos = npc.position.clone().add(npc.userData.dir.clone().multiplyScalar(speed * dt));
                
                // –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤—ã—Ö–æ–¥ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã (–Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –ø—Ä–µ–≤–µ–Ω—Ç–∏–≤–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª)
                if (Math.abs(nextPos.x) > MAP_SIZE || Math.abs(nextPos.z) > MAP_SIZE) {
                    npc.userData.dir.applyAxisAngle(new THREE.Vector3(0,1,0), Math.PI + (Math.random()-0.5)*0.5);
                } else {
                    npc.position.copy(nextPos); 
                    if (npc.userData.state !== 'POLICE' || !currentCar) {
                        npc.lookAt(npc.position.clone().add(npc.userData.dir)); 
                    }
                }
            });
            
            updateMiniMap(); 
            updateParticles(); renderer.render(scene, camera);
        }

        // --- –û–°–¢–ê–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ---
        function createMapBounds() {
            const bounds = MAP_SIZE + BORDER_COLLISION_SIZE / 2;
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x808080, 
                opacity: 0.1, 
                transparent: true,
                roughness: 0.9, 
                metalness: 0.1 
            }); 
            const wall1 = new THREE.Mesh(new THREE.BoxGeometry(MAP_SIZE * 2 + BORDER_COLLISION_SIZE * 2, VISIBLE_WALL_HEIGHT, BORDER_COLLISION_SIZE), material); wall1.position.set(0, VISIBLE_WALL_HEIGHT/2, -bounds); collisionObjects.push(wall1); scene.add(wall1);
            const wall2 = new THREE.Mesh(new THREE.BoxGeometry(MAP_SIZE * 2 + BORDER_COLLISION_SIZE * 2, VISIBLE_WALL_HEIGHT, BORDER_COLLISION_SIZE), material); wall2.position.set(0, VISIBLE_WALL_HEIGHT/2, bounds); collisionObjects.push(wall2); scene.add(wall2);
            const wall3 = new THREE.Mesh(new THREE.BoxGeometry(BORDER_COLLISION_SIZE, VISIBLE_WALL_HEIGHT, MAP_SIZE * 2), material); wall3.position.set(-bounds, VISIBLE_WALL_HEIGHT/2, 0); collisionObjects.push(wall3); scene.add(wall3);
            const wall4 = new THREE.Mesh(new THREE.BoxGeometry(BORDER_COLLISION_SIZE, VISIBLE_WALL_HEIGHT, MAP_SIZE * 2), material); wall4.position.set(bounds, VISIBLE_WALL_HEIGHT/2, 0); collisionObjects.push(wall4); scene.add(wall4);
        }
        
        // –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Ä–µ—Å–ø–∞—É–Ω–∞
        function respawnNPCs() {
            const currentCivs = npcs.filter(n => !n.userData.isPolice).length;
            const currentPolice = npcs.filter(n => n.userData.isPolice).length;
            
            const missingCivs = NPC_COUNT - POLICE_COUNT - currentCivs;
            const missingPolice = POLICE_COUNT - currentPolice;

            if (missingCivs > 0) {
                spawnNPCs(missingCivs, false);
            }
            // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ –≤—Å–µ–≥–¥–∞ –±—É–¥–µ—Ç –Ω—É–∂–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª–∏—Ü–∏–∏
            if (missingPolice > 0) {
                spawnNPCs(missingPolice, true);
            }
        }
        
        function createCity() {
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE * 2 + 100, MAP_SIZE * 2 + 100), new THREE.MeshStandardMaterial({ color: 0xCCCCCC })); ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
            const parkingLot = new THREE.Mesh(new THREE.PlaneGeometry(30, 40), new THREE.MeshStandardMaterial({ color: 0x222222 })); parkingLot.rotation.x = -Math.PI/2; parkingLot.position.set(-15, 0.02, 0); parkingLot.receiveShadow = true; scene.add(parkingLot); 
            const lineGeo = new THREE.PlaneGeometry(0.2, 10); const lineMat = new THREE.MeshBasicMaterial({color: 0xffff00});
            const line1 = new THREE.Mesh(lineGeo, lineMat); line1.rotation.x = -Math.PI/2; line1.position.set(-10, 0.03, -10); scene.add(line1);
            const line2 = new THREE.Mesh(lineGeo, lineMat); line2.rotation.x = -Math.PI/2; line2.position.set(-20, 0.03, -10); scene.add(line2);

            const blockSize = 50;
            for(let x = -MAP_SIZE; x <= MAP_SIZE; x+=blockSize) {
                for(let z = -MAP_SIZE; z <= MAP_SIZE; z+=blockSize) {
                    if (x > -30 && x < 30 && z > -30 && z < 40) continue; 
                    if (Math.abs(x) < MAP_SIZE && Math.abs(z) < MAP_SIZE && (x % 100 === 0 || z % 100 === 0)) {
                            const roadPatch = new THREE.Mesh(new THREE.PlaneGeometry(blockSize, blockSize), new THREE.MeshStandardMaterial({ color: 0x333333 })); roadPatch.rotation.x = -Math.PI/2; roadPatch.position.set(x, 0.01, z); scene.add(roadPatch);
                    }
                    if (Math.abs(x) < MAP_SIZE - 50 && Math.abs(z) < MAP_SIZE - 50 && Math.abs(x) % 100 !== 0 && Math.abs(z) % 100 !== 0) {
                        const h = Math.random() * 25 + 10; const w = blockSize - 15;
                        const building = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshStandardMaterial({ color: 0xDCDCDC, roughness: 0.8 }));
                        building.position.set(x, h/2, z); building.castShadow = true; building.receiveShadow = true; 
                        scene.add(building); 
                        collisionObjects.push(building); 
                        const roof = new THREE.Mesh(new THREE.ConeGeometry(w/1.5, 4, 4), new THREE.MeshStandardMaterial({color: Math.random()>0.5?0x8b0000:0x2e8b57})); roof.position.set(x, h + 2, z); roof.rotation.y = Math.PI/4; roof.castShadow = true; scene.add(roof);
                        
                        mapBuildings.push({x: x, z: z, w: w, d: w});
                    }
                    else if (Math.abs(x) > MAP_SIZE - 50 || Math.abs(z) > MAP_SIZE - 50) {
                            if (Math.random() > 0.95) createTree(x + Math.random()*10, z + Math.random()*10); 
                    }
                }
            }
        }
        function createStreetFurniture() {
            createBench(-40, 0.01, 5, 0); 
            createBench(-100, 0.01, -5, 0);
        }
        function createTree(x, z) {
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 3), new THREE.MeshStandardMaterial({color:0x5c4033})); trunk.position.set(x, 1.5, z); trunk.castShadow = true; scene.add(trunk); collisionObjects.push(trunk);
            const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(2.5), new THREE.MeshStandardMaterial({color:0x228b22})); leaves.position.set(x, 4, z); scene.add(leaves);
        }
        function createCarMesh(color, isPolice) {
            const group = new THREE.Group();
            const bodyColor = isPolice ? 0x0000FF : color; 
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.7, 4.6), new THREE.MeshStandardMaterial({color: bodyColor})); body.position.y = 0.6; group.add(body);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.6, 2.5), new THREE.MeshStandardMaterial({color: 0x111111})); cabin.position.set(0, 1.2, -0.1); group.add(cabin);
            const wMat = new THREE.MeshStandardMaterial({color: 0x000000});
            const wGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.4, 16); wGeo.rotateZ(Math.PI/2);
            [[1.1,1.5],[-1.1,1.5],[1.1,-1.5],[-1.1,-1.5]].forEach(p=>{
                const w=new THREE.Mesh(wGeo,wMat); w.position.set(p[0],0.45,p[1]); group.add(w);
            });
            
            if (isPolice) {
                const light = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.1, 0.3), new THREE.MeshBasicMaterial({color: 0xFF0000, transparent: true, opacity: 0.8}));
                light.position.set(0, 1.5, 0.8);
                group.add(light);
            }

            group.userData = { speed: 0, steering: 0, isPoliceCar: isPolice, isBeingUsedByPolice: false, lastShotTime: 0 };
            return group;
        }
        function getRandomMapPosition() {
            let x = (Math.random()-0.5) * MAP_SIZE * 2 * 0.9; 
            let z = (Math.random()-0.5) * MAP_SIZE * 2 * 0.9;
            return {x, z};
        }
        
        function spawnTraffic() {
            for(let i=0; i<TRAFFIC_CAR_COUNT; i++) {
                const isPolice = Math.random() < 0.1; 
                const car = createCarMesh(Math.random()*0xffffff, isPolice);
                
                let x, z;
                do {
                    x = (Math.random()-0.5) * MAP_SIZE * 2 * 0.9; 
                    z = (Math.random()-0.5) * MAP_SIZE * 2 * 0.9;
                } while (Math.abs(x) < 30 && Math.abs(z) < 30); 
                
                car.position.set(x, 0, z); 
                car.rotation.y = Math.random() * Math.PI * 2; 
                car.castShadow = true; 
                scene.add(car); 
                cars.push(car); 
                collisionObjects.push(car.children[0]);
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è spawnNPCs —Å —Ñ–ª–∞–≥–æ–º isPolice
        function spawnNPCs(count, isPolice) {
            for(let i=0; i<count; i++) {
                const group = new THREE.Group();
                const bodyColor = isPolice ? 0x000088 : Math.random()*0xffffff;
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.5, 0.3), new THREE.MeshStandardMaterial({color: bodyColor})); body.position.y = 0.75;
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.25), new THREE.MeshStandardMaterial({color: 0xffe0bd})); head.position.y = 1.6;
                group.add(body); group.add(head);
                const {x, z} = getRandomMapPosition();
                group.position.set(x, 0, z); group.castShadow = true;
                group.userData = { isPolice: isPolice, hp: 100, state: 'WALK', dir: new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).normalize(), hasWeapon: isPolice ? 'PISTOL' : 'FIST' };
                scene.add(group); npcs.push(group);
            }
        }
        
        function tryEnterCar() {
            if (currentCar) {
                player.position.copy(currentCar.position); player.position.x -= 3; player.position.y = CAMERA_HEIGHT; player.visible = true; player.add(camera); camera.position.set(0,0,0); camera.rotation.set(0,0,0); currentCar = null; document.getElementById('crosshair').style.display = 'block'; document.getElementById('weaponDisplay').style.display = 'block'; weaponGroup.visible = true;
            } else {
                let closest = null; let minD = 5;
                cars.forEach(c => { const d = player.position.distanceTo(c.position); if(d<minD){ minD=d; closest=c; }});
                if (closest && !closest.userData.isBeingUsedByPolice) { 
                    currentCar = closest; player.visible = false; scene.add(camera); document.getElementById('crosshair').style.display = 'none'; document.getElementById('weaponDisplay').style.display = 'none'; document.getElementById('carHint').style.display = 'none'; weaponGroup.visible = false; carSpeed = 0;
                }
            }
        }
        function killNPC(npc, byCar) { 
            createBlood(npc.position); 
            if(byCar) playSound('hit'); 
            
            if (npc.userData.isPolice) {
                 wantedLevel = Math.min(wantedLevel + 3, 5);
                 if (policeCar && policeCar.userData.isBeingUsedByPolice) policeCar = null; 
            } else {
                 wantedLevel = Math.min(wantedLevel + 1, 5);
            }
            
            scene.remove(npc); 
            npcs.splice(npcs.indexOf(npc), 1); 
            npcs.forEach(n => { if(!n.userData.isPolice) n.userData.state = 'PANIC'; }); 
            document.getElementById('wantedLevel').innerText = "‚òÖ –†–û–ó–´–°–ö: " + wantedLevel; 
            // –†–µ—Å–ø–∞—É–Ω –±—É–¥–µ—Ç –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω —á–µ—Ä–µ–∑ setInterval(respawnNPCs, ...)
        }
        function createBlood(pos) { for(let k=0; k<8; k++) { const m = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color:0x880000})); m.position.copy(pos); m.position.x+=(Math.random()-0.5); m.position.z+=(Math.random()-0.5); m.position.y=0.1; scene.add(m); particles.push({mesh:m, life:100}); } }
        function updateParticles() { for(let i=particles.length-1; i>=0; i--) { particles[i].life--; if(particles[i].life<=0) { scene.remove(particles[i].mesh); particles.splice(i,1); } } }
        function createWeapons() { weaponGroup = new THREE.Group(); camera.add(weaponGroup); weaponGroup.position.set(0.3, -0.4, -0.5); const fist = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshStandardMaterial({color: 0xffccaa})); fist.name = 'FIST'; weaponGroup.add(fist); const gun = new THREE.Group(); gun.visible = false; gun.name = 'PISTOL'; gun.add(new THREE.Mesh(new THREE.BoxGeometry(0.08,0.08,0.4), new THREE.MeshStandardMaterial({color:0x111111}))); weaponGroup.add(gun); }
        function onKeyDown(e) { if(e.code==='KeyW') moveFwd=true; if(e.code==='KeyS') moveBwd=true; if(e.code==='KeyA') moveLft=true; if(e.code==='KeyD') moveRgt=true; if(e.code==='KeyF') tryEnterCar(); if(e.code==='Digit1'&&!currentCar) { currentWeapon='FIST'; weaponGroup.children[0].visible=true; weaponGroup.children[1].visible=false; document.getElementById('weaponDisplay').innerText='üëä –ö–£–õ–ê–ö–ò'; } if(e.code==='Digit2'&&!currentCar) { currentWeapon='PISTOL'; weaponGroup.children[0].visible=false; weaponGroup.children[1].visible=true; document.getElementById('weaponDisplay').innerText='üî´ –ü–ò–°–¢–û–õ–ï–¢'; } }
        function onKeyUp(e) { if(e.code==='KeyW') moveFwd=false; if(e.code==='KeyS') moveBwd=false; if(e.code==='KeyA') moveLft=false; if(e.code==='KeyD') moveRgt=false; }
        function onMouseMove(e) { if(currentCar||document.pointerLockElement!==document.body) return; player.rotation.y -= e.movementX*0.002; camera.rotation.x -= e.movementY*0.002; camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x)); }
        
        function onMouseDown() { 
            if(!isGameActive) return; 
            if(currentCar) return; 
            if(document.pointerLockElement!==document.body) { document.body.requestPointerLock(); return; } 
            
            if (currentWeapon === 'PISTOL') {
                camera.rotation.x -= 0.05; 
                setTimeout(() => {
                    camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x + 0.05));
                }, 100);
            }
            
            playSound(currentWeapon==='FIST'?'punch':'shoot'); 
            weaponGroup.position.z = -0.2; setTimeout(()=>weaponGroup.position.z=-0.5, 100); 
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera); 
            const hits = raycaster.intersectObjects(npcs, true); 
            
            if(hits.length > 0) { 
                const d = hits[0].distance; 
                if(d < (currentWeapon==='FIST'?3:150)) { 
                    let t = hits[0].object; 
                    while(t.parent && t.parent.type!=='Scene') t=t.parent; 
                    
                    t.userData.hp -= (currentWeapon==='FIST'?50:100); 
                    
                    if(t.userData.hp<=0) killNPC(t, false); 
                    else { 
                        npcs.forEach(n => { if(!n.userData.isPolice) n.userData.state = 'PANIC'; });
                        wantedLevel = Math.min(wantedLevel+1, 5); 
                        document.getElementById('wantedLevel').innerText = "‚òÖ –†–û–ó–´–°–ö: " + wantedLevel; 
                    } 
                } 
            } 
        }

        function endGame() { 
            isGameActive = false; 
            document.exitPointerLock(); 
            document.getElementById('bustedScreen').style.display = 'flex'; 
        }

        document.getElementById('startBtn').addEventListener('click', () => { 
            document.getElementById('menu').style.display = 'none'; 
            init(); 
            isGameActive = true; 
            document.body.requestPointerLock(); 
            document.getElementById('hpDisplay').innerText = `‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: ${playerHP}`;
        });

        document.getElementById('help-btn').addEventListener('click', () => {
             document.getElementById('infoBox').style.display = 'block';
        });
        
        // --- –ó–í–£–ö–ò (–ó–∞–≥–ª—É—à–∫–∏) ---
        function playSound(name) {
             const osc = audioCtx.createOscillator();
             const gain = audioCtx.createGain();
             osc.connect(gain);
             gain.connect(audioCtx.destination);

             switch(name) {
                case 'punch':
                    osc.type = 'square'; osc.frequency.setValueAtTime(50, audioCtx.currentTime); gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                    break;
                case 'shoot':
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(800, audioCtx.currentTime); gain.gain.setValueAtTime(0.7, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
                    break;
                default: 
                    return;
             }
             osc.start(); osc.stop(audioCtx.currentTime + 0.2);
        }
    </script>
</body>
</html>